{"version":3,"file":"archiveWorker-rFP_5GeN.js","sources":["../node_modules/fflate/esm/browser.js","../src/parser/tarExtractor.ts","../src/parser/constants.ts","../src/parser/utils.ts","../src/parser/LogStore.ts","../src/parser/planProcessor.ts","../src/parser/panicProcessor.ts","../src/parser/logParser.ts","../node_modules/js-yaml/dist/js-yaml.mjs","../src/parser/planYamlParser.ts","../src/parser/v2v/v2vHelpers.ts","../src/parser/v2v/hivexParser.ts","../src/parser/v2v/nbdkitParser.ts","../src/parser/v2v/guestInfoParser.ts","../src/parser/v2v/fileCopyParser.ts","../src/parser/v2v/parseHandlers.ts","../src/parser/v2vLogParser.ts","../src/parser/mergeResults.ts","../src/parser/v2v/pathClassifier.ts","../src/parser/archiveProcessor.ts","../src/parser/archiveWorker.ts"],"sourcesContent":["// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","/**\n * Browser-based tar/gzip/zip extraction with recursive nested archive support.\n *\n * Uses the native DecompressionStream API for gzip and manually parses\n * the tar format (512-byte headers).  Gzipped archives are parsed in a\n * **streaming** fashion so the entire decompressed content is never held\n * in memory at once.  ZIP files are extracted via the `fflate` library.\n * Nested .tar / .tar.gz / .tgz / .zip entries are recursively extracted\n * and flattened into a single list.\n */\n\nimport { unzip as fflateUnzip } from 'fflate';\n\n//  Types \n\nexport interface TarEntry {\n  /** Full path inside the archive (nested paths are joined with '/') */\n  path: string;\n  /** Text content decoded via UTF-8 */\n  content: string;\n  /** Raw bytes  kept so nested tars can be re-parsed */\n  rawBytes: Uint8Array;\n}\n\n//  Constants \n\nconst TAR_BLOCK = 512;\nconst GZIP_MAGIC_0 = 0x1f;\nconst GZIP_MAGIC_1 = 0x8b;\n\n/** Skip individual files larger than this (50 MB) to avoid memory pressure */\nconst MAX_ENTRY_BYTES = 50 * 1024 * 1024;\n\n/**\n * File extensions that are definitely not text/log/yaml content.\n * Skipping these avoids the cost of UTF-8 decoding + string allocation\n * for files that will never match any classifier.\n */\nconst SKIP_EXTENSIONS = new Set([\n  '.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico', '.svg', '.bmp',\n  '.mp4', '.webm', '.avi', '.mov', '.mp3', '.wav', '.ogg',\n  '.woff', '.woff2', '.ttf', '.otf', '.eot',\n  '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',\n  '.exe', '.dll', '.so', '.dylib', '.o', '.a',\n  '.class', '.pyc', '.pyo', '.wasm',\n  '.db', '.sqlite', '.sqlite3',\n  '.rpm', '.deb', '.dmg', '.iso',\n]);\n\n/** Check if a file path ends with a known non-text extension */\nfunction shouldSkipByExtension(path: string): boolean {\n  const lower = path.toLowerCase();\n  const dotIdx = lower.lastIndexOf('.');\n  if (dotIdx === -1) return false;\n  return SKIP_EXTENSIONS.has(lower.slice(dotIdx));\n}\n\n//  Public API \n\n/**\n * Extract all files from a tar or tar.gz archive supplied as a File or\n * Uint8Array.  Nested archives (.tar, .tar.gz, .tgz) are recursively\n * extracted and the results flattened.\n */\nexport async function extractArchive(\n  input: File | Uint8Array,\n  pathPrefix = '',\n): Promise<TarEntry[]> {\n  const bytes = input instanceof File\n    ? new Uint8Array(await input.arrayBuffer())\n    : input;\n\n  // Route to ZIP extractor if the content is a ZIP file\n  if (isZip(bytes)) {\n    return extractZip(bytes, pathPrefix);\n  }\n\n  // Otherwise handle as tar (gzipped or plain)\n  const rawEntries = isGzip(bytes)\n    ? await streamParseGzippedTar(bytes, pathPrefix)\n    : parseTarBytes(bytes, pathPrefix);\n\n  // Recursively extract nested archives\n  return flattenNestedArchives(rawEntries);\n}\n\n//  Recursive flattening \n\nasync function flattenNestedArchives(entries: TarEntry[]): Promise<TarEntry[]> {\n  const result: TarEntry[] = [];\n\n  for (const entry of entries) {\n    if (isArchiveEntry(entry.path)) {\n      try {\n        const prefix = stripArchiveExt(entry.path);\n        // Route to the right extractor based on content magic bytes\n        const nested = isZip(entry.rawBytes)\n          ? await extractZip(entry.rawBytes, prefix)\n          : await extractArchive(entry.rawBytes, prefix);\n        result.push(...nested);\n      } catch {\n        // If nested extraction fails, keep the entry as-is\n        result.push(entry);\n      }\n    } else {\n      result.push(entry);\n    }\n  }\n\n  return result;\n}\n\n//  Streaming gzip+tar parser \n\n/**\n * Decompress a gzipped tar and parse entries in one streaming pass.\n * The full decompressed content is **never** materialised in memory.\n */\nasync function streamParseGzippedTar(\n  compressed: Uint8Array,\n  pathPrefix: string,\n): Promise<TarEntry[]> {\n  // Pipe compressed bytes through DecompressionStream\n  const inputStream = new ReadableStream<Uint8Array>({\n    start(controller) {\n      // Enqueue the compressed buffer and close\n      controller.enqueue(compressed);\n      controller.close();\n    },\n  });\n\n  const decompressed = inputStream.pipeThrough(\n    new DecompressionStream('gzip') as unknown as TransformStream<Uint8Array, Uint8Array>,\n  );\n  const reader = decompressed.getReader();\n  const buf = new StreamingBuffer(reader);\n\n  return parseTarFromStream(buf, pathPrefix);\n}\n\n//  StreamingBuffer \n\n/**\n * Wraps a ReadableStreamDefaultReader and provides exact-byte-count read\n * and efficient skip operations.  Only the data currently being processed\n * is kept in memory.\n */\nclass StreamingBuffer {\n  private reader: ReadableStreamDefaultReader<Uint8Array>;\n  private buffer: Uint8Array = new Uint8Array(0);\n  private eof = false;\n\n  constructor(reader: ReadableStreamDefaultReader<Uint8Array>) {\n    this.reader = reader;\n  }\n\n  /** Read exactly `n` bytes.  Returns null if the stream ends first. */\n  async readExact(n: number): Promise<Uint8Array | null> {\n    // Fast path: already have enough buffered\n    if (this.buffer.byteLength >= n) {\n      const result = this.buffer.slice(0, n);\n      this.buffer = this.buffer.subarray(n);\n      return result;\n    }\n\n    // Collect chunks until we have enough\n    const chunks: Uint8Array[] = [this.buffer];\n    let collected = this.buffer.byteLength;\n    this.buffer = new Uint8Array(0);\n\n    while (collected < n && !this.eof) {\n      const { done, value } = await this.reader.read();\n      if (done) {\n        this.eof = true;\n        break;\n      }\n      chunks.push(value);\n      collected += value.byteLength;\n    }\n\n    if (collected < n) return null;\n\n    // Concatenate once\n    const combined = new Uint8Array(collected);\n    let offset = 0;\n    for (const chunk of chunks) {\n      combined.set(chunk, offset);\n      offset += chunk.byteLength;\n    }\n\n    const result = combined.slice(0, n);\n    if (collected > n) {\n      this.buffer = combined.subarray(n);\n    }\n    return result;\n  }\n\n  /**\n   * Skip `n` bytes efficiently without accumulating them.\n   * Chunks are consumed and discarded as they arrive.\n   */\n  async skip(n: number): Promise<void> {\n    let remaining = n;\n\n    // First consume from the existing buffer\n    if (this.buffer.byteLength > 0) {\n      if (this.buffer.byteLength >= remaining) {\n        this.buffer = this.buffer.subarray(remaining);\n        return;\n      }\n      remaining -= this.buffer.byteLength;\n      this.buffer = new Uint8Array(0);\n    }\n\n    // Consume and discard chunks from the stream\n    while (remaining > 0 && !this.eof) {\n      const { done, value } = await this.reader.read();\n      if (done) {\n        this.eof = true;\n        break;\n      }\n      if (value.byteLength > remaining) {\n        // Keep the leftover\n        this.buffer = value.subarray(remaining);\n        remaining = 0;\n      } else {\n        remaining -= value.byteLength;\n      }\n    }\n  }\n}\n\n//  Streaming tar parser \n\nasync function parseTarFromStream(\n  buf: StreamingBuffer,\n  pathPrefix: string,\n): Promise<TarEntry[]> {\n  const entries: TarEntry[] = [];\n  const decoder = new TextDecoder('utf-8', { fatal: false });\n  let longName = '';\n\n  for (;;) {\n    // Read 512-byte header\n    const header = await buf.readExact(TAR_BLOCK);\n    if (!header) break; // stream ended\n\n    // Two consecutive zero blocks  end-of-archive\n    if (isZeroBlock(header)) {\n      // Try to read the next block to check for second zero block\n      const next = await buf.readExact(TAR_BLOCK);\n      if (!next || isZeroBlock(next)) break;\n      // Not a second zero block  treat `next` as the next header\n      // (push it back by re-processing below; but our buffer API doesn't\n      //  support unread, so we process it inline)\n      const entry = await processHeader(next, buf, decoder, pathPrefix, longName);\n      if (entry === 'longname') {\n        longName = await readLongName(buf, next, decoder);\n      } else {\n        if (entry) entries.push(entry);\n        longName = '';\n      }\n      continue;\n    }\n\n    const headerResult = await processHeader(header, buf, decoder, pathPrefix, longName);\n    if (headerResult === 'longname') {\n      longName = await readLongName(buf, header, decoder);\n    } else {\n      if (headerResult) entries.push(headerResult);\n      longName = '';\n    }\n  }\n\n  return entries;\n}\n\n/**\n * Process a single tar header and its associated data.\n * Returns a TarEntry, the string 'longname' if this was a GNU LongName\n * header (caller should read the long name), or null to skip.\n */\nasync function processHeader(\n  header: Uint8Array,\n  buf: StreamingBuffer,\n  decoder: TextDecoder,\n  pathPrefix: string,\n  longName: string,\n): Promise<TarEntry | 'longname' | null> {\n  const rawName = readString(header, 0, 100);\n  const sizeOctal = readString(header, 124, 12);\n  const typeFlag = readString(header, 156, 1);\n  const prefix = readString(header, 345, 155);\n\n  const size = parseOctal(sizeOctal);\n  const aligned = alignToBlock(size);\n\n  // GNU LongName (type 'L')  caller will read the content\n  if (typeFlag === 'L') {\n    return 'longname';\n  }\n\n  // Build file name\n  let name = longName || (prefix ? `${prefix}/${rawName}` : rawName);\n  name = name.replace(/\\0+$/, '');\n  const fullPath = pathPrefix ? `${pathPrefix}/${name}` : name;\n\n  // Skip directories, empty files, and non-regular files\n  if (\n    typeFlag === '5' ||\n    name.endsWith('/') ||\n    size === 0 ||\n    (typeFlag !== '0' && typeFlag !== '' && typeFlag !== '\\0')\n  ) {\n    await buf.skip(aligned);\n    return null;\n  }\n\n  // Skip oversized entries to avoid memory pressure\n  if (size > MAX_ENTRY_BYTES) {\n    await buf.skip(aligned);\n    return null;\n  }\n\n  // Skip known binary/media files (avoids costly UTF-8 decode + string alloc)\n  if (!isArchiveEntry(fullPath) && shouldSkipByExtension(fullPath)) {\n    await buf.skip(aligned);\n    return null;\n  }\n\n  // Read file content\n  const rawBytes = await buf.readExact(aligned);\n  if (!rawBytes) return null;\n\n  const fileBytes = rawBytes.slice(0, size);\n  const content = decoder.decode(fileBytes);\n\n  return { path: fullPath, content, rawBytes: fileBytes };\n}\n\n/** Read the content of a GNU LongName header entry */\nasync function readLongName(\n  buf: StreamingBuffer,\n  header: Uint8Array,\n  decoder: TextDecoder,\n): Promise<string> {\n  const sizeOctal = readString(header, 124, 12);\n  const size = parseOctal(sizeOctal);\n  const aligned = alignToBlock(size);\n\n  const nameBytes = await buf.readExact(aligned);\n  if (!nameBytes) return '';\n  return decoder.decode(nameBytes.subarray(0, size)).replace(/\\0+$/, '');\n}\n\n//  Synchronous parser for in-memory (non-gzipped) tars \n\nfunction parseTarBytes(bytes: Uint8Array, pathPrefix: string): TarEntry[] {\n  const entries: TarEntry[] = [];\n  let offset = 0;\n  const decoder = new TextDecoder('utf-8', { fatal: false });\n  let longName = '';\n\n  while (offset + TAR_BLOCK <= bytes.length) {\n    const header = bytes.subarray(offset, offset + TAR_BLOCK);\n\n    if (isZeroBlock(header)) {\n      if (\n        offset + 2 * TAR_BLOCK <= bytes.length &&\n        isZeroBlock(bytes.subarray(offset + TAR_BLOCK, offset + 2 * TAR_BLOCK))\n      ) {\n        break;\n      }\n      offset += TAR_BLOCK;\n      continue;\n    }\n\n    const rawName = readString(header, 0, 100);\n    const sizeOctal = readString(header, 124, 12);\n    const typeFlag = readString(header, 156, 1);\n    const prefix = readString(header, 345, 155);\n\n    const size = parseOctal(sizeOctal);\n    offset += TAR_BLOCK; // move past header\n\n    // GNU LongName\n    if (typeFlag === 'L') {\n      const nameBytes = bytes.subarray(offset, offset + size);\n      longName = decoder.decode(nameBytes).replace(/\\0+$/, '');\n      offset += alignToBlock(size);\n      continue;\n    }\n\n    let name = longName || (prefix ? `${prefix}/${rawName}` : rawName);\n    longName = '';\n    name = name.replace(/\\0+$/, '');\n    const fullPath = pathPrefix ? `${pathPrefix}/${name}` : name;\n\n    // Skip directories, empty, non-regular, oversized, known-binary\n    if (\n      typeFlag === '5' ||\n      name.endsWith('/') ||\n      size === 0 ||\n      (typeFlag !== '0' && typeFlag !== '' && typeFlag !== '\\0') ||\n      size > MAX_ENTRY_BYTES ||\n      (!isArchiveEntry(fullPath) && shouldSkipByExtension(fullPath))\n    ) {\n      offset += alignToBlock(size);\n      continue;\n    }\n\n    const rawBytes = bytes.slice(offset, offset + size);\n    const content = decoder.decode(rawBytes);\n    entries.push({ path: fullPath, content, rawBytes });\n\n    offset += alignToBlock(size);\n  }\n\n  return entries;\n}\n\n//  ZIP extraction \n\nconst ZIP_MAGIC_0 = 0x50; // 'P'\nconst ZIP_MAGIC_1 = 0x4b; // 'K'\n\nfunction isZip(bytes: Uint8Array): boolean {\n  return (\n    bytes.length >= 4 &&\n    bytes[0] === ZIP_MAGIC_0 &&\n    bytes[1] === ZIP_MAGIC_1 &&\n    (bytes[2] === 0x03 || bytes[2] === 0x05 || bytes[2] === 0x07) &&\n    (bytes[3] === 0x04 || bytes[3] === 0x06 || bytes[3] === 0x08)\n  );\n}\n\n/**\n * Wrap fflate's callback-based unzip in a Promise.\n */\nfunction unzipAsync(data: Uint8Array): Promise<Record<string, Uint8Array>> {\n  return new Promise((resolve, reject) => {\n    fflateUnzip(data, (err, result) => {\n      if (err) reject(err);\n      else resolve(result);\n    });\n  });\n}\n\n/**\n * Extract all files from a ZIP archive.\n * Returns TarEntry[] for compatibility with the rest of the pipeline.\n */\nexport async function extractZip(\n  input: File | Uint8Array,\n  pathPrefix = '',\n): Promise<TarEntry[]> {\n  const bytes = input instanceof File\n    ? new Uint8Array(await input.arrayBuffer())\n    : input;\n\n  const files = await unzipAsync(bytes);\n  const decoder = new TextDecoder('utf-8', { fatal: false });\n  const entries: TarEntry[] = [];\n\n  for (const [name, data] of Object.entries(files)) {\n    // Skip directories (fflate includes them as empty entries)\n    if (name.endsWith('/') || data.length === 0) continue;\n    // Skip oversized entries\n    if (data.length > MAX_ENTRY_BYTES) continue;\n    const fullPath = pathPrefix ? `${pathPrefix}/${name}` : name;\n    // Skip known binary/media files\n    if (!isArchiveEntry(fullPath) && shouldSkipByExtension(name)) continue;\n    const content = decoder.decode(data);\n    entries.push({ path: fullPath, content, rawBytes: data });\n  }\n\n  // Recursively extract nested archives\n  return flattenNestedArchives(entries);\n}\n\n//  Public Helpers \n\n/**\n * Check whether raw bytes represent a ZIP archive.\n */\nexport { isZip };\n\n/**\n * Decompress a gzipped file (non-tar) and return the text content.\n * Uses the native DecompressionStream API.\n */\nexport async function decompressGzipToText(file: File): Promise<string> {\n  const buf = await file.arrayBuffer();\n  const bytes = new Uint8Array(buf);\n\n  if (!isGzip(bytes)) {\n    // Not actually gzipped  decode as plain text\n    return new TextDecoder('utf-8').decode(bytes);\n  }\n\n  const inputStream = new ReadableStream<Uint8Array>({\n    start(controller) {\n      controller.enqueue(bytes);\n      controller.close();\n    },\n  });\n\n  const decompressed = inputStream.pipeThrough(\n    new DecompressionStream('gzip') as unknown as TransformStream<Uint8Array, Uint8Array>,\n  );\n\n  const reader = decompressed.getReader();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    chunks.push(value);\n    totalLength += value.length;\n  }\n\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n\n  return new TextDecoder('utf-8').decode(result);\n}\n\n//  Internal Helpers \n\nfunction isGzip(bytes: Uint8Array): boolean {\n  return (\n    bytes.length >= 2 &&\n    bytes[0] === GZIP_MAGIC_0 &&\n    bytes[1] === GZIP_MAGIC_1\n  );\n}\n\nfunction isZeroBlock(block: Uint8Array): boolean {\n  for (let i = 0; i < block.length; i++) {\n    if (block[i] !== 0) return false;\n  }\n  return true;\n}\n\nfunction readString(buf: Uint8Array, offset: number, length: number): string {\n  let end = offset + length;\n  while (end > offset && buf[end - 1] === 0) end--;\n  const slice = buf.subarray(offset, end);\n  return new TextDecoder('ascii').decode(slice);\n}\n\nfunction parseOctal(str: string): number {\n  const trimmed = str.trim();\n  if (!trimmed) return 0;\n  return parseInt(trimmed, 8) || 0;\n}\n\n/** Round up to the next 512-byte boundary */\nfunction alignToBlock(size: number): number {\n  return Math.ceil(size / TAR_BLOCK) * TAR_BLOCK;\n}\n\n/** Check if a path looks like an archive entry (tar or zip) */\nfunction isArchiveEntry(path: string): boolean {\n  const lower = path.toLowerCase();\n  return (\n    lower.endsWith('.tar') ||\n    lower.endsWith('.tar.gz') ||\n    lower.endsWith('.tgz') ||\n    lower.endsWith('.zip')\n  );\n}\n\n/** Strip the archive extension to use as a path prefix for nested contents */\nfunction stripArchiveExt(path: string): string {\n  const lower = path.toLowerCase();\n  if (lower.endsWith('.tar.gz')) return path.slice(0, -7);\n  if (lower.endsWith('.tgz')) return path.slice(0, -4);\n  if (lower.endsWith('.tar')) return path.slice(0, -4);\n  if (lower.endsWith('.zip')) return path.slice(0, -4);\n  return path;\n}\n","// Migration types\nexport const MigrationTypes = {\n  Unknown: 'Unknown',\n  Warm: 'Warm',\n  Cold: 'Cold',\n  OnlyConversion: 'OnlyConversion',\n} as const;\n\n// Plan statuses\nexport const PlanStatuses = {\n  Pending: 'Pending',\n  Ready: 'Ready',\n  Running: 'Running',\n  Succeeded: 'Succeeded',\n  Failed: 'Failed',\n} as const;\n\n// Pipeline steps\nexport const PipelineSteps = {\n  Unknown: 'Unknown',\n  Initialize: 'Initialize',\n  PreflightInspection: 'PreflightInspection',\n  DiskAllocation: 'DiskAllocation',\n  DiskTransfer: 'DiskTransfer',\n  DiskTransferV2v: 'DiskTransferV2v',\n  Cutover: 'Cutover',\n  ImageConversion: 'ImageConversion',\n  VMCreation: 'VMCreation',\n} as const;\n\n// Common VM phases\nexport const Phases = {\n  Started: 'Started',\n  PreHook: 'PreHook',\n  PostHook: 'PostHook',\n  Completed: 'Completed',\n  // Warm and cold phases\n  AddCheckpoint: 'AddCheckpoint',\n  AddFinalCheckpoint: 'AddFinalCheckpoint',\n  AllocateDisks: 'AllocateDisks',\n  ConvertGuest: 'ConvertGuest',\n  ConvertOpenstackSnapshot: 'ConvertOpenstackSnapshot',\n  CopyDisks: 'CopyDisks',\n  CopyDisksVirtV2V: 'CopyDisksVirtV2V',\n  CopyingPaused: 'CopyingPaused',\n  CreateDataVolumes: 'CreateDataVolumes',\n  CreateFinalSnapshot: 'CreateFinalSnapshot',\n  CreateGuestConversionPod: 'CreateGuestConversionPod',\n  CreateInitialSnapshot: 'CreateInitialSnapshot',\n  CreateSnapshot: 'CreateSnapshot',\n  CreateVM: 'CreateVM',\n  Finalize: 'Finalize',\n  PreflightInspection: 'PreflightInspection',\n  PowerOffSource: 'PowerOffSource',\n  RemoveFinalSnapshot: 'RemoveFinalSnapshot',\n  RemovePenultimateSnapshot: 'RemovePenultimateSnapshot',\n  RemovePreviousSnapshot: 'RemovePreviousSnapshot',\n  StoreInitialSnapshotDeltas: 'StoreInitialSnapshotDeltas',\n  StorePowerState: 'StorePowerState',\n  StoreSnapshotDeltas: 'StoreSnapshotDeltas',\n  WaitForDataVolumesStatus: 'WaitForDataVolumesStatus',\n  WaitForFinalSnapshot: 'WaitForFinalSnapshot',\n  WaitForFinalSnapshotRemoval: 'WaitForFinalSnapshotRemoval',\n  WaitForInitialSnapshot: 'WaitForInitialSnapshot',\n  WaitForPenultimateSnapshotRemoval: 'WaitForPenultimateSnapshotRemoval',\n  WaitForPowerOff: 'WaitForPowerOff',\n  WaitForPreviousSnapshotRemoval: 'WaitForPreviousSnapshotRemoval',\n  WaitForSnapshot: 'WaitForSnapshot',\n} as const;\n\n// Precopy loop phases (can repeat multiple times in warm migration)\n// Order: CopyDisks -> CopyingPaused -> RemovePreviousSnapshot -> WaitForPreviousSnapshotRemoval\n//        -> CreateSnapshot -> WaitForSnapshot -> StoreSnapshotDeltas -> AddCheckpoint\nexport const PrecopyLoopPhases: string[] = [\n  Phases.CopyDisks,\n  Phases.CopyingPaused,\n  Phases.RemovePreviousSnapshot,\n  Phases.WaitForPreviousSnapshotRemoval,\n  Phases.CreateSnapshot,\n  Phases.WaitForSnapshot,\n  Phases.StoreSnapshotDeltas,\n  Phases.AddCheckpoint,\n];\n\nexport const PrecopyLoopPhasesSet: Set<string> = new Set(PrecopyLoopPhases);\n\n// First phase of the precopy loop (used to detect new iterations)\nexport const PrecopyLoopStartPhase = Phases.CopyDisks;\n\n// Warm-only phases\nexport const WarmOnlyPhases: Set<string> = new Set([\n  Phases.CreateInitialSnapshot,\n  Phases.WaitForInitialSnapshot,\n  Phases.StoreInitialSnapshotDeltas,\n  Phases.WaitForDataVolumesStatus,\n  Phases.CopyingPaused,\n  Phases.RemovePreviousSnapshot,\n  Phases.WaitForPreviousSnapshotRemoval,\n  Phases.CreateSnapshot,\n  Phases.WaitForSnapshot,\n  Phases.StoreSnapshotDeltas,\n  Phases.AddCheckpoint,\n  Phases.RemovePenultimateSnapshot,\n  Phases.WaitForPenultimateSnapshotRemoval,\n  Phases.CreateFinalSnapshot,\n  Phases.WaitForFinalSnapshot,\n  Phases.AddFinalCheckpoint,\n  Phases.Finalize,\n  Phases.RemoveFinalSnapshot,\n  Phases.WaitForFinalSnapshotRemoval,\n]);\n\n// Cold disk phases\nexport const ColdDiskPhases: Set<string> = new Set([\n  Phases.CopyDisks,\n  Phases.AllocateDisks,\n  Phases.CopyDisksVirtV2V,\n]);\n\n// Warm migration phases (ordered)\nexport const WarmMigrationPhases = [\n  Phases.Started,\n  Phases.PreHook,\n  Phases.CreateInitialSnapshot,\n  Phases.WaitForInitialSnapshot,\n  Phases.StoreInitialSnapshotDeltas,\n  Phases.PreflightInspection,\n  Phases.CreateDataVolumes,\n  Phases.WaitForDataVolumesStatus,\n  Phases.CopyDisks,\n  Phases.CopyingPaused,\n  Phases.RemovePreviousSnapshot,\n  Phases.WaitForPreviousSnapshotRemoval,\n  Phases.CreateSnapshot,\n  Phases.WaitForSnapshot,\n  Phases.StoreSnapshotDeltas,\n  Phases.AddCheckpoint,\n  Phases.StorePowerState,\n  Phases.PowerOffSource,\n  Phases.WaitForPowerOff,\n  Phases.RemovePenultimateSnapshot,\n  Phases.WaitForPenultimateSnapshotRemoval,\n  Phases.CreateFinalSnapshot,\n  Phases.WaitForFinalSnapshot,\n  Phases.AddFinalCheckpoint,\n  Phases.Finalize,\n  Phases.RemoveFinalSnapshot,\n  Phases.WaitForFinalSnapshotRemoval,\n  Phases.CreateGuestConversionPod,\n  Phases.ConvertGuest,\n  Phases.CreateVM,\n  Phases.PostHook,\n  Phases.Completed,\n];\n\n// Cold migration phases (ordered)\nexport const ColdMigrationPhases = [\n  Phases.Started,\n  Phases.PreHook,\n  Phases.StorePowerState,\n  Phases.PowerOffSource,\n  Phases.WaitForPowerOff,\n  Phases.CreateDataVolumes,\n  Phases.AllocateDisks,\n  Phases.CreateGuestConversionPod,\n  Phases.ConvertGuest,\n  Phases.CopyDisksVirtV2V,\n  Phases.CreateVM,\n  Phases.PostHook,\n  Phases.Completed,\n];\n\n// Only conversion phases (ordered)\nexport const OnlyConversionPhases = [\n  Phases.Started,\n  Phases.PreHook,\n  Phases.StorePowerState,\n  Phases.PowerOffSource,\n  Phases.WaitForPowerOff,\n  Phases.CreateGuestConversionPod,\n  Phases.ConvertGuest,\n  Phases.CreateVM,\n  Phases.PostHook,\n  Phases.Completed,\n];\n\n// Get phases for migration type\nexport function getPhasesForMigrationType(migrationType: string): string[] {\n  switch (migrationType) {\n    case MigrationTypes.Warm:\n      return WarmMigrationPhases;\n    case MigrationTypes.Cold:\n      return ColdMigrationPhases;\n    case MigrationTypes.OnlyConversion:\n      return OnlyConversionPhases;\n    default:\n      return [...WarmMigrationPhases]; // Return all phases for unknown\n  }\n}\n\n// Map phase to pipeline step\nexport function phaseToStep(phase: string, isWarm: boolean): string {\n  switch (phase) {\n    case Phases.Started:\n    case Phases.CreateInitialSnapshot:\n    case Phases.WaitForInitialSnapshot:\n    case Phases.StoreInitialSnapshotDeltas:\n      return PipelineSteps.Initialize;\n    case Phases.AllocateDisks:\n      return PipelineSteps.DiskAllocation;\n    case Phases.CopyDisks:\n    case Phases.CopyingPaused:\n    case Phases.RemovePreviousSnapshot:\n    case Phases.WaitForPreviousSnapshotRemoval:\n    case Phases.CreateSnapshot:\n    case Phases.WaitForSnapshot:\n    case Phases.StoreSnapshotDeltas:\n    case Phases.AddCheckpoint:\n    case Phases.ConvertOpenstackSnapshot:\n      return PipelineSteps.DiskTransfer;\n    case Phases.CreateDataVolumes:\n    case Phases.WaitForDataVolumesStatus:\n      return PipelineSteps.Initialize;\n    case Phases.RemovePenultimateSnapshot:\n    case Phases.WaitForPenultimateSnapshotRemoval:\n    case Phases.CreateFinalSnapshot:\n    case Phases.WaitForFinalSnapshot:\n    case Phases.AddFinalCheckpoint:\n    case Phases.Finalize:\n    case Phases.RemoveFinalSnapshot:\n    case Phases.WaitForFinalSnapshotRemoval:\n      return PipelineSteps.Cutover;\n    case Phases.CreateGuestConversionPod:\n    case Phases.ConvertGuest:\n      return PipelineSteps.ImageConversion;\n    case Phases.CopyDisksVirtV2V:\n      return PipelineSteps.DiskTransferV2v;\n    case Phases.CreateVM:\n      return PipelineSteps.VMCreation;\n    case Phases.PreHook:\n    case Phases.PostHook:\n      return phase;\n    case Phases.StorePowerState:\n    case Phases.PowerOffSource:\n    case Phases.WaitForPowerOff:\n      return isWarm ? PipelineSteps.Cutover : PipelineSteps.Initialize;\n    case Phases.PreflightInspection:\n      return PipelineSteps.PreflightInspection;\n    case Phases.Completed:\n      return PipelineSteps.VMCreation;\n    default:\n      return PipelineSteps.Unknown;\n  }\n}\n\n// Condition status values\nexport const ConditionStatus = {\n  True: 'True',\n  False: 'False',\n} as const;\n\n// Panic-related constants\nexport const PanicPrefix = 'panic:';\nexport const GoroutinePrefix = 'goroutine ';\n\n// Container log regex pattern\nexport const ContainerLogPrefixRegex = /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)\\s+(\\{.*)$/;\n\n// VM regex pattern\nexport const VMRegex = /id:(vm-\\d+)\\s+name:'([^']+)'/;\n\n// Short display names for phases\nexport const PhaseShortNames: Record<string, string> = {\n  'Started': 'Start',\n  'PreHook': 'PreHook',\n  'StorePowerState': 'StorePwr',\n  'PowerOffSource': 'PwrOff',\n  'WaitForPowerOff': 'WaitPwr',\n  'CreateDataVolumes': 'CreateDV',\n  'CreateSnapshot': 'CreateSnap',\n  'WaitForSnapshot': 'WaitSnap',\n  'StoreSnapshot': 'StoreSnap',\n  'AddCheckpoint': 'AddChkpt',\n  'AddFinalCheckpoint': 'FinalChkpt',\n  'CreateInitialSnapshot': 'InitSnap',\n  'WaitForInitialSnapshot': 'WaitInit',\n  'StoreInitialSnapshotDeltas': 'StoreDeltas',\n  'Preflight': 'Preflight',\n  'PreflightInspection': 'Preflight',\n  'CreateVM': 'CreateVM',\n  'Initialize': 'Init',\n  'DiskTransfer': 'DiskTransfer',\n  'DiskTransferV2v': 'DiskV2V',\n  'DiskAllocation': 'DiskAlloc',\n  'Cutover': 'Cutover',\n  'ImageConversion': 'ImgConv',\n  'VirtualMachineCreation': 'CreateVM',\n  'CopyDisks': 'Copy',\n  'CopyDisksVirtV2V': 'CopyV2V',\n  'CreateGuestConversionPod': 'ConvPod',\n  'ConvertGuest': 'Convert',\n  'CopyingPaused': 'Paused',\n  'AllocateDisks': 'Allocate',\n  'WaitForDataVolumes': 'WaitDV',\n  'RemovePenultimateSnapshot': 'RmPenSnap',\n  'WaitForPenultimateSnapshotRemoval': 'WaitRmPen',\n  'RemoveFinalSnapshot': 'RmFinalSnap',\n  'WaitForFinalSnapshotRemoval': 'WaitRmFinal',\n  'Finalize': 'Finalize',\n  'FinalSnapshot': 'FinalSnap',\n  'WaitForFinalSnapshot': 'WaitFinal',\n  'WaitForFinalDataVolumes': 'WaitFinalDV',\n  'RemovePreviousSnapshot': 'RmPrevSnap',\n  'WaitForPreviousSnapshotRemoval': 'WaitRmPrev',\n  'PostHook': 'PostHook',\n  'Completed': 'Done',\n  'Canceled': 'Cancel',\n  'StoreSnapshotDeltas': 'StoreDeltas',\n  'WaitForDataVolumesStatus': 'WaitDVStatus',\n  'CreateFinalSnapshot': 'FinalSnap',\n  'ConvertOpenstackSnapshot': 'ConvOSSnap',\n};\n\n/**\n * Get a shortened version of the phase name for display\n */\nexport function getShortPhaseName(phase: string): string {\n  return PhaseShortNames[phase] || phase.replace(/([a-z])([A-Z])/g, '$1\\u200B$2').slice(0, 10);\n}\n","import type { LogEntry, VM, RawLogEntry, GroupedLogEntry, PhaseLogSummary, PhaseInfo, WarmInfo, PrecopyInfo } from '../types';\nimport { VMRegex, WarmOnlyPhases, ColdDiskPhases, MigrationTypes, Phases, PrecopyLoopPhasesSet, PrecopyLoopStartPhase } from './constants';\n\n/**\n * Parse various log timestamp formats\n */\nexport function parseTimestamp(ts: string): Date {\n  if (!ts) return new Date(0);\n\n  // Try ISO 8601 / RFC 3339 format (container logs)\n  let date = new Date(ts);\n  if (!isNaN(date.getTime())) {\n    return date;\n  }\n\n  // Try standard log format with milliseconds \"2026-02-05 02:57:29.093\"\n  const stdMatch = ts.match(/^(\\d{4}-\\d{2}-\\d{2})\\s+(\\d{2}:\\d{2}:\\d{2})(?:\\.(\\d+))?$/);\n  if (stdMatch) {\n    const [, datePart, timePart, ms] = stdMatch;\n    const isoStr = `${datePart}T${timePart}${ms ? `.${ms}` : ''}Z`;\n    date = new Date(isoStr);\n    if (!isNaN(date.getTime())) {\n      return date;\n    }\n  }\n\n  return new Date(0);\n}\n\n/**\n * Parse VM info from string format \"id:vm-1002 name:'ameen-RHEL9'\"\n */\nexport function parseVMInfo(vmStr: string): { id: string; name: string } {\n  const matches = vmStr.match(VMRegex);\n  if (matches && matches.length >= 3) {\n    return { id: matches[1], name: matches[2] };\n  }\n  return { id: '', name: '' };\n}\n\n/**\n * Get VM info from log entry (either from vmRef or vm string/object)\n */\nexport function getVMInfo(entry: LogEntry): { id: string; name: string } {\n  // Try VMRef first (structured format)\n  if (entry.vmRef?.id) {\n    return { id: entry.vmRef.id, name: entry.vmRef.name || '' };\n  }\n  // Check if vm field exists\n  if (entry.vm) {\n    // Handle vm as string format: \"id:vm-1002 name:'ameen-RHEL9'\"\n    if (typeof entry.vm === 'string') {\n      return parseVMInfo(entry.vm);\n    }\n    // Handle vm as object: { id?: string; name?: string }\n    const vmObj = entry.vm as { id?: string; name?: string };\n    return { id: vmObj.id || '', name: vmObj.name || '' };\n  }\n  return { id: '', name: '' };\n}\n\n/**\n * Truncate string to max length\n */\nexport function truncate(s: string, maxLen: number): string {\n  if (s.length <= maxLen) return s;\n  return s.slice(0, maxLen) + '...';\n}\n\n/**\n * Safely extract string from object\n */\nexport function getStringFromMap(obj: Record<string, unknown> | undefined, key: string): string {\n  if (!obj) return '';\n  const value = obj[key];\n  return typeof value === 'string' ? value : '';\n}\n\n/**\n * Format duration in human-readable format\n */\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${ms}ms`;\n  }\n  if (ms < 60000) {\n    return `${(ms / 1000).toFixed(1)}s`;\n  }\n  if (ms < 3600000) {\n    const mins = Math.floor(ms / 60000);\n    const secs = Math.floor((ms % 60000) / 1000);\n    return `${mins}m ${secs}s`;\n  }\n  const hours = Math.floor(ms / 3600000);\n  const mins = Math.floor((ms % 3600000) / 60000);\n  return `${hours}h ${mins}m`;\n}\n\n/**\n * Detect migration type for a VM based on phases\n */\nexport function detectVMMigrationType(phaseHistory: PhaseInfo[]): string {\n  let hasWarmPhase = false;\n  let hasDiskPhase = false;\n  let hasConversion = false;\n\n  for (const ph of phaseHistory) {\n    if (WarmOnlyPhases.has(ph.name)) {\n      hasWarmPhase = true;\n    }\n    if (ColdDiskPhases.has(ph.name)) {\n      hasDiskPhase = true;\n    }\n    if (ph.name === Phases.CreateGuestConversionPod || ph.name === Phases.ConvertGuest) {\n      hasConversion = true;\n    }\n  }\n\n  if (hasWarmPhase) {\n    return MigrationTypes.Warm;\n  }\n  if (hasConversion && !hasDiskPhase) {\n    return MigrationTypes.OnlyConversion;\n  }\n  if (hasDiskPhase || phaseHistory.length > 0) {\n    return MigrationTypes.Cold;\n  }\n  return MigrationTypes.Unknown;\n}\n\n/**\n * Group similar log entries by message\n */\nexport function groupLogs(logs: RawLogEntry[]): GroupedLogEntry[] {\n  const groups = new Map<string, GroupedLogEntry>();\n  const order: string[] = [];\n\n  for (const log of logs) {\n    const existing = groups.get(log.message);\n    if (existing) {\n      existing.count++;\n      existing.lastSeen = log.timestamp;\n      existing.entries.push(log);\n    } else {\n      groups.set(log.message, {\n        message: log.message,\n        count: 1,\n        firstSeen: log.timestamp,\n        lastSeen: log.timestamp,\n        level: log.level,\n        entries: [log],\n      });\n      order.push(log.message);\n    }\n  }\n\n  return order.map(msg => groups.get(msg)!);\n}\n\n/**\n * Compute phase log summaries for a VM\n */\nexport function computePhaseLogSummaries(vm: VM): Record<string, PhaseLogSummary> {\n  if (!vm.phaseLogs) return {};\n\n  const summaries: Record<string, PhaseLogSummary> = {};\n\n  // Build phase times map\n  const phaseTimes = new Map<string, PhaseInfo>();\n  for (const ph of vm.phaseHistory) {\n    phaseTimes.set(ph.name, ph);\n  }\n\n  for (const [phase, logs] of Object.entries(vm.phaseLogs)) {\n    if (logs.length === 0) continue;\n\n    const summary: PhaseLogSummary = {\n      phase,\n      totalLogs: logs.length,\n      groupedLogs: groupLogs(logs),\n    };\n\n    // Get phase timing from history\n    const phaseInfo = phaseTimes.get(phase);\n    if (phaseInfo) {\n      if (phaseInfo.startedAt) {\n        summary.startTime = phaseInfo.startedAt.toISOString();\n      }\n      if (phaseInfo.endedAt) {\n        summary.endTime = phaseInfo.endedAt.toISOString();\n        if (phaseInfo.startedAt) {\n          const durationMs = phaseInfo.endedAt.getTime() - phaseInfo.startedAt.getTime();\n          summary.durationMs = durationMs;\n          summary.duration = formatDuration(durationMs);\n        }\n      }\n    }\n\n    summaries[phase] = summary;\n  }\n\n  return summaries;\n}\n\n/**\n * Build WarmInfo from controller log phase history.\n * Groups precopy loop phases by iteration number and derives timing/summary.\n */\nexport function buildWarmInfoFromPhaseHistory(phaseHistory: PhaseInfo[]): WarmInfo | undefined {\n  // Collect all precopy loop phases that have an iteration number\n  const iterationMap = new Map<number, PhaseInfo[]>();\n  for (const ph of phaseHistory) {\n    if (PrecopyLoopPhasesSet.has(ph.name) && ph.iteration) {\n      const phases = iterationMap.get(ph.iteration) || [];\n      phases.push(ph);\n      iterationMap.set(ph.iteration, phases);\n    }\n  }\n\n  if (iterationMap.size === 0) return undefined;\n\n  const precopies: PrecopyInfo[] = [];\n  let successes = 0;\n  let failures = 0;\n\n  // Sort by iteration number\n  const sortedIterations = Array.from(iterationMap.entries()).sort((a, b) => a[0] - b[0]);\n\n  for (const [iteration, phases] of sortedIterations) {\n    // Find the earliest start and latest end across all phases in this iteration\n    let startedAt: Date | undefined;\n    let endedAt: Date | undefined;\n    let allPhasesCompleted = true;\n\n    for (const ph of phases) {\n      if (ph.startedAt) {\n        if (!startedAt || ph.startedAt < startedAt) {\n          startedAt = ph.startedAt;\n        }\n      }\n      if (ph.endedAt) {\n        if (!endedAt || ph.endedAt > endedAt) {\n          endedAt = ph.endedAt;\n        }\n      } else {\n        allPhasesCompleted = false;\n      }\n    }\n\n    const durationMs = startedAt && endedAt\n      ? endedAt.getTime() - startedAt.getTime()\n      : undefined;\n\n    // Check if this iteration has the final loop phase (AddCheckpoint) completed\n    const hasAddCheckpoint = phases.some(\n      ph => ph.name === Phases.AddCheckpoint && ph.endedAt\n    );\n\n    // Check if the first phase of this iteration started (CopyDisks)\n    const hasCopyDisksStart = phases.some(\n      ph => ph.name === PrecopyLoopStartPhase && ph.startedAt\n    );\n\n    if (hasAddCheckpoint) {\n      successes++;\n    } else if (hasCopyDisksStart && !allPhasesCompleted) {\n      // Iteration started but didn't complete - could be in progress or failed\n      // Only count as failure if there's a subsequent iteration (meaning this one was retried)\n      const hasLaterIteration = sortedIterations.some(([i]) => i > iteration);\n      if (hasLaterIteration) {\n        failures++;\n      }\n    }\n\n    precopies.push({\n      iteration,\n      snapshot: `iteration-${iteration}`,\n      startedAt,\n      endedAt,\n      durationMs,\n      disks: [],\n    });\n  }\n\n  return {\n    precopies,\n    successes,\n    failures,\n    consecutiveFailures: 0,\n  };\n}\n\n/**\n * Check if a line looks like part of a panic stack trace\n */\nexport function isPanicLine(line: string): boolean {\n  return line.startsWith('panic:') || line.startsWith('goroutine ');\n}\n","import type {\n  Plan,\n  Event,\n  ParseStats,\n  Summary,\n  MigrationType,\n} from '../types';\nimport { PlanStatuses, MigrationTypes, phaseToStep } from './constants';\nimport { computePhaseLogSummaries, detectVMMigrationType, buildWarmInfoFromPhaseHistory } from './utils';\n\n/**\n * LogStore manages parsed data during log file processing\n */\nexport class LogStore {\n  private plans: Map<string, Plan> = new Map();\n  private events: Event[] = [];\n  private stats: ParseStats = {\n    totalLines: 0,\n    parsedLines: 0,\n    errorLines: 0,\n    duplicateLines: 0,\n    plansFound: 0,\n    vmsFound: 0,\n  };\n  private processedLines: Set<string> = new Set();\n\n  /**\n   * Check if a line has already been processed\n   */\n  isLineProcessed(line: string): boolean {\n    return this.processedLines.has(line);\n  }\n\n  /**\n   * Mark a line as processed\n   */\n  markLineProcessed(line: string): void {\n    this.processedLines.add(line);\n  }\n\n  /**\n   * Get or create a plan\n   */\n  getOrCreatePlan(namespace: string, name: string): Plan {\n    const key = `${namespace}/${name}`;\n    let plan = this.plans.get(key);\n    \n    if (!plan) {\n      plan = {\n        name,\n        namespace,\n        status: PlanStatuses.Pending,\n        archived: false,\n        migrationType: MigrationTypes.Unknown,\n        conditions: [],\n        vms: {},\n        errors: [],\n        panics: [],\n        firstSeen: new Date(0),\n        lastSeen: new Date(0),\n      };\n      this.plans.set(key, plan);\n    }\n    \n    return plan;\n  }\n\n  /**\n   * Find a plan by key (namespace/name)\n   */\n  findPlan(key: string): Plan | undefined {\n    return this.plans.get(key);\n  }\n\n  /**\n   * Get the most recent plan (by lastSeen)\n   */\n  getMostRecentPlan(): Plan | undefined {\n    let mostRecent: Plan | undefined;\n    for (const plan of this.plans.values()) {\n      if (!mostRecent || plan.lastSeen > mostRecent.lastSeen) {\n        mostRecent = plan;\n      }\n    }\n    return mostRecent;\n  }\n\n  /**\n   * Add an event to the timeline\n   */\n  addEvent(event: Event): void {\n    this.events.push(event);\n  }\n\n  /**\n   * Update stats\n   */\n  updateStats(partial: Partial<ParseStats>): void {\n    Object.assign(this.stats, partial);\n  }\n\n  /**\n   * Increment a stat counter\n   */\n  incrementStat(key: keyof ParseStats): void {\n    this.stats[key]++;\n  }\n\n  /**\n   * Get all plans with computed summaries\n   */\n  getAllPlans(): Plan[] {\n    const plans: Plan[] = [];\n    \n    for (const plan of this.plans.values()) {\n      // Compute phase log summaries and migration type for each VM\n      for (const vm of Object.values(plan.vms)) {\n        vm.phaseLogSummaries = computePhaseLogSummaries(vm);\n        vm.migrationType = detectVMMigrationType(vm.phaseHistory) as MigrationType;\n        \n        const isWarm = vm.migrationType === MigrationTypes.Warm;\n        if (vm.currentPhase) {\n          vm.currentStep = phaseToStep(vm.currentPhase, isWarm);\n        }\n        \n        // Build warmInfo from controller log phase history for warm VMs\n        // (YAML-sourced VMs already have warmInfo set)\n        if (isWarm && !vm.warmInfo) {\n          const warmInfo = buildWarmInfoFromPhaseHistory(vm.phaseHistory);\n          if (warmInfo) {\n            vm.warmInfo = warmInfo;\n            vm.precopyCount = warmInfo.precopies.length;\n          }\n        }\n\n        // Update step info in phase history\n        for (const ph of vm.phaseHistory) {\n          ph.step = phaseToStep(ph.name, isWarm);\n        }\n      }\n      \n      // Detect plan migration type\n      plan.migrationType = this.detectPlanMigrationType(plan) as MigrationType;\n      plans.push(plan);\n    }\n    \n    return plans;\n  }\n\n  /**\n   * Detect plan migration type based on VMs\n   */\n  private detectPlanMigrationType(plan: Plan): string {\n    let hasWarm = false;\n    let hasCold = false;\n    let hasOnlyConversion = false;\n\n    for (const vm of Object.values(plan.vms)) {\n      const vmType = detectVMMigrationType(vm.phaseHistory);\n      switch (vmType) {\n        case MigrationTypes.Warm:\n          hasWarm = true;\n          break;\n        case MigrationTypes.Cold:\n          hasCold = true;\n          break;\n        case MigrationTypes.OnlyConversion:\n          hasOnlyConversion = true;\n          break;\n      }\n    }\n\n    if (hasWarm) return MigrationTypes.Warm;\n    if (hasCold) return MigrationTypes.Cold;\n    if (hasOnlyConversion) return MigrationTypes.OnlyConversion;\n    return MigrationTypes.Unknown;\n  }\n\n  /**\n   * Get events\n   */\n  getEvents(): Event[] {\n    return this.events;\n  }\n\n  /**\n   * Get summary\n   */\n  getSummary(): Summary {\n    const summary: Summary = {\n      totalPlans: this.plans.size,\n      running: 0,\n      succeeded: 0,\n      failed: 0,\n      archived: 0,\n      pending: 0,\n    };\n\n    for (const plan of this.plans.values()) {\n      if (plan.archived) {\n        summary.archived++;\n      }\n      switch (plan.status) {\n        case PlanStatuses.Running:\n          summary.running++;\n          break;\n        case PlanStatuses.Succeeded:\n          summary.succeeded++;\n          break;\n        case PlanStatuses.Failed:\n          summary.failed++;\n          break;\n        case PlanStatuses.Pending:\n        case PlanStatuses.Ready:\n          summary.pending++;\n          break;\n      }\n    }\n\n    return summary;\n  }\n\n  /**\n   * Get parse stats\n   */\n  getStats(): ParseStats {\n    // Update plan and VM counts\n    this.stats.plansFound = this.plans.size;\n    let vmsFound = 0;\n    for (const plan of this.plans.values()) {\n      vmsFound += Object.keys(plan.vms).length;\n    }\n    this.stats.vmsFound = vmsFound;\n    return this.stats;\n  }\n\n  /**\n   * Get the complete parse result\n   */\n  getResult() {\n    return {\n      plans: this.getAllPlans(),\n      events: this.events,\n      summary: this.getSummary(),\n      stats: this.getStats(),\n      networkMaps: [],\n      storageMaps: [],\n    };\n  }\n\n  /**\n   * Clear all data\n   */\n  clear(): void {\n    this.plans.clear();\n    this.events = [];\n    this.stats = {\n      totalLines: 0,\n      parsedLines: 0,\n      errorLines: 0,\n      duplicateLines: 0,\n      plansFound: 0,\n      vmsFound: 0,\n    };\n    this.processedLines.clear();\n  }\n}\n","import type { LogEntry, Plan, VM, Condition, RawLogEntry, WarmInfo, PrecopyInfo } from '../types';\nimport { LogStore } from './LogStore';\nimport { PlanStatuses, Phases, ConditionStatus, PrecopyLoopPhasesSet, PrecopyLoopStartPhase, MigrationTypes } from './constants';\nimport { getVMInfo, truncate, getStringFromMap } from './utils';\n\n/**\n * Create a new VM object with the given id, name, and timestamp.\n */\nfunction createVM(id: string, name: string, ts: Date): VM {\n  return {\n    id,\n    name,\n    currentPhase: '',\n    currentStep: '',\n    migrationType: MigrationTypes.Unknown,\n    transferMethod: 'Unknown',\n    phaseHistory: [],\n    dataVolumes: [],\n    createdResources: [],\n    phaseLogs: {},\n    firstSeen: ts,\n    lastSeen: ts,\n  };\n}\n\n/**\n * Process plan-related log entries\n */\nexport function processPlanLog(store: LogStore, entry: LogEntry, ts: Date): void {\n  // Extract plan name and namespace\n  const planName = entry.plan?.name || '';\n  const namespace = entry.plan?.namespace || '';\n\n  if (!planName || !namespace) return;\n\n  const plan = store.getOrCreatePlan(namespace, planName);\n\n  // Skip logs from old migrations (except migration start events which reset the plan)\n  const msg = entry.msg || '';\n  if (entry.migration && plan.migration && entry.migration !== plan.migration) {\n    // Allow Migration [STARTED] to go through as it resets the plan\n    if (msg !== 'Migration [STARTED]') {\n      return; // Skip logs from old migration runs\n    }\n  }\n\n  // Update timestamps\n  if (plan.firstSeen.getTime() === 0) {\n    plan.firstSeen = ts;\n  }\n  plan.lastSeen = ts;\n\n  // Ensure VM exists if this log references one\n  const { id: vmID } = getVMInfo(entry);\n  if (vmID) {\n    ensureVMExists(plan, entry, ts);\n  }\n\n  // Check for archived plan\n  if (msg.includes('Aborting reconcile of archived plan')) {\n    plan.archived = true;\n    return;\n  }\n\n  // Check for succeeded plan\n  if (msg.includes('Skipping reconcile of succeeded plan')) {\n    plan.status = PlanStatuses.Succeeded;\n    return;\n  }\n\n  // Check for migration start\n  if (msg === 'Migration [STARTED]') {\n    // If this is a new migration (rerun), reset the plan data\n    if (entry.migration && plan.migration && entry.migration !== plan.migration) {\n      // New migration detected - reset VMs, errors, panics, conditions\n      plan.vms = {};\n      plan.errors = [];\n      plan.panics = [];\n      plan.conditions = [];\n      plan.firstSeen = ts;\n    }\n    \n    plan.status = PlanStatuses.Running;\n    if (entry.migration) {\n      plan.migration = entry.migration;\n    }\n    store.addEvent({\n      timestamp: entry.ts,\n      type: 'migration_start',\n      planName,\n      namespace,\n      description: 'Migration started',\n    });\n    return;\n  }\n\n  // Check for migration succeeded\n  if (msg === 'Migration [SUCCEEDED]') {\n    plan.status = PlanStatuses.Succeeded;\n    // Mark all VMs in this plan as Completed\n    for (const vm of Object.values(plan.vms)) {\n      if (vm.currentPhase !== Phases.Completed) {\n        // Close previous phase\n        if (vm.phaseHistory.length > 0) {\n          const lastPhase = vm.phaseHistory[vm.phaseHistory.length - 1];\n          if (!lastPhase.endedAt) {\n            lastPhase.endedAt = ts;\n          }\n        }\n        vm.currentPhase = Phases.Completed;\n        vm.phaseHistory.push({\n          name: Phases.Completed,\n          step: '',\n          startedAt: ts,\n          endedAt: ts,\n        });\n      }\n    }\n    store.addEvent({\n      timestamp: entry.ts,\n      type: 'migration_succeeded',\n      planName,\n      namespace,\n      description: 'Migration succeeded',\n    });\n    return;\n  }\n\n  // Check for migration run with phase\n  if (msg === 'Migration [RUN]' && vmID) {\n    processVMPhase(store, plan, entry, ts);\n    storeVMLog(plan, entry);\n    return;\n  }\n\n  // Check for SetCheckpoint (warm migration precopy data)\n  if (msg === 'SetCheckpoint' && vmID) {\n    processSetCheckpoint(plan, entry, ts);\n    storeVMLog(plan, entry);\n    return;\n  }\n\n  // Check for itinerary transition\n  if (msg === 'Itinerary transition') {\n    processPhaseTransition(store, plan, entry, ts);\n    return;\n  }\n\n  // Check for condition changes\n  if (msg.startsWith('Condition added')) {\n    processConditionAdded(store, plan, entry, ts);\n    return;\n  }\n\n  if (msg.startsWith('Condition deleted')) {\n    processConditionDeleted(plan, entry);\n    return;\n  }\n\n  // Check for storage offload (VSphereXcopy populator)\n  if (detectStorageOffload(entry)) {\n    markVMStorageOffload(plan, entry);\n  }\n\n  // Check for DataVolume creation\n  if (msg === 'Created DataVolume.' && entry.dv) {\n    processDataVolume(plan, entry, ts);\n    return;\n  }\n\n  // Check for other resource creations\n  if (msg.includes('created.') || msg.startsWith('Created ')) {\n    processCreatedResource(plan, entry, ts, msg);\n    return;\n  }\n\n  // Check for error-level logs with 'error' field\n  if (entry.level === 'error' && entry.error) {\n    processErrorLog(store, plan, planName, namespace, entry, ts);\n    return;\n  }\n\n  // Check for active migration found\n  if (msg.includes('Found (active) migration')) {\n    plan.status = PlanStatuses.Running;\n    if (entry.migration) {\n      plan.migration = entry.migration;\n    }\n    return;\n  }\n\n  // Check for 'err' field in logs (warnings/errors that don't fail the plan)\n  if (entry.err) {\n    processWarningLog(store, plan, planName, namespace, entry, ts);\n  }\n\n  // For any other log that mentions a VM, store it under that VM's current phase\n  if (vmID) {\n    storeVMLog(plan, entry);\n  }\n}\n\n/**\n * Ensure VM exists in plan\n */\nexport function ensureVMExists(plan: Plan, entry: LogEntry, ts: Date): void {\n  const { id: vmID, name: vmName } = getVMInfo(entry);\n  if (!vmID) return;\n\n  let vm = plan.vms[vmID];\n  if (!vm) {\n    vm = createVM(vmID, vmName, ts);\n    plan.vms[vmID] = vm;\n  }\n\n  vm.lastSeen = ts;\n\n  // Update phase if entry has one and VM doesn't have a current phase yet\n  if (entry.phase && !vm.currentPhase) {\n    vm.currentPhase = entry.phase;\n    vm.phaseHistory.push({\n      name: entry.phase,\n      step: '',\n      startedAt: ts,\n    });\n  }\n}\n\n/**\n * Get the current precopy loop iteration for a VM\n */\nfunction getCurrentPrecopyIteration(vm: { phaseHistory: { name: string; iteration?: number }[] }): number {\n  // Find the highest iteration number from precopy loop phases\n  let maxIteration = 0;\n  for (const phase of vm.phaseHistory) {\n    if (PrecopyLoopPhasesSet.has(phase.name) && phase.iteration) {\n      maxIteration = Math.max(maxIteration, phase.iteration);\n    }\n  }\n  return maxIteration;\n}\n\n/**\n * Process VM phase updates\n */\nfunction processVMPhase(store: LogStore, plan: Plan, entry: LogEntry, ts: Date): void {\n  const { id: vmID, name: vmName } = getVMInfo(entry);\n  if (!vmID) return;\n\n  let vm = plan.vms[vmID];\n  if (!vm) {\n    vm = createVM(vmID, vmName, ts);\n    plan.vms[vmID] = vm;\n  }\n\n  vm.lastSeen = ts;\n\n  // Update phase if changed\n  if (entry.phase && entry.phase !== vm.currentPhase) {\n    // Close previous phase\n    if (vm.phaseHistory.length > 0) {\n      const lastPhase = vm.phaseHistory[vm.phaseHistory.length - 1];\n      if (!lastPhase.endedAt) {\n        lastPhase.endedAt = ts;\n      }\n    }\n\n    // Determine iteration number for precopy loop phases\n    let iteration: number | undefined;\n    if (PrecopyLoopPhasesSet.has(entry.phase)) {\n      const currentIteration = getCurrentPrecopyIteration(vm);\n      \n      if (entry.phase === PrecopyLoopStartPhase) {\n        // Starting a new loop iteration\n        iteration = currentIteration + 1;\n      } else {\n        // Continuation of current iteration (or first iteration if none yet)\n        iteration = currentIteration || 1;\n      }\n    }\n\n    // Start new phase\n    vm.currentPhase = entry.phase;\n    vm.phaseHistory.push({\n      name: entry.phase,\n      step: '',\n      startedAt: ts,\n      iteration,\n    });\n\n    const iterationSuffix = iteration ? ` (iteration ${iteration})` : '';\n    store.addEvent({\n      timestamp: entry.ts,\n      type: 'phase_change',\n      planName: plan.name,\n      namespace: plan.namespace,\n      vmName,\n      description: `VM entered phase: ${entry.phase}${iterationSuffix}`,\n      phase: entry.phase,\n    });\n  }\n\n  // Check if completed\n  if (entry.phase === Phases.Completed) {\n    plan.status = PlanStatuses.Succeeded;\n  }\n}\n\n/**\n * Process SetCheckpoint log entries to extract warm migration precopy data.\n * The SetCheckpoint message contains accumulated precopies with snapshot names,\n * disk deltas, and timing information.\n */\nfunction processSetCheckpoint(plan: Plan, entry: LogEntry, _ts: Date): void {\n  const { id: vmID } = getVMInfo(entry);\n  if (!vmID) return;\n\n  const vm = plan.vms[vmID];\n  if (!vm) return;\n\n  // Access extra fields from the SetCheckpoint entry\n  const entryRecord = entry as unknown as Record<string, unknown>;\n  const precopies = entryRecord.precopies as Array<{\n    start?: string;\n    end?: string;\n    snapshot?: string;\n    createTaskId?: string;\n    removeTaskId?: string;\n    deltas?: Array<{ disk?: string; deltaId?: string }>;\n  }> | undefined;\n\n  if (!precopies || precopies.length === 0) return;\n\n  // Build PrecopyInfo from the raw precopies data\n  const precopyInfos: PrecopyInfo[] = precopies.map((p, i) => {\n    const start = p.start ? new Date(p.start) : undefined;\n    const end = p.end ? new Date(p.end) : undefined;\n    const durationMs = start && end ? end.getTime() - start.getTime() : undefined;\n    return {\n      iteration: i + 1,\n      snapshot: p.snapshot || 'unknown',\n      startedAt: start,\n      endedAt: end,\n      durationMs,\n      disks: (p.deltas || []).map(d => d.disk || '').filter(Boolean),\n    };\n  });\n\n  // Count successes (precopies with an end time) and failures\n  const successes = precopyInfos.filter(p => p.endedAt).length;\n  const totalAttempted = precopyInfos.length;\n  const failures = totalAttempted - successes - (precopyInfos.some(p => !p.endedAt) ? 1 : 0); // Don't count in-progress as failure\n\n  // Check if this is the final checkpoint\n  const isFinal = entryRecord.final === true;\n\n  const warmInfo: WarmInfo = {\n    precopies: precopyInfos,\n    successes,\n    failures: failures > 0 ? failures : 0,\n    consecutiveFailures: 0,\n  };\n\n  // Always update warmInfo with the latest SetCheckpoint data (accumulates)\n  vm.warmInfo = warmInfo;\n  vm.precopyCount = precopyInfos.length;\n\n  // Mark as warm migration if not already set\n  if (vm.migrationType === 'Unknown') {\n    vm.migrationType = 'Warm';\n  }\n\n  // Store final checkpoint info for reference\n  if (isFinal) {\n    vm.warmInfo.consecutiveFailures = 0; // Final checkpoint means success\n  }\n}\n\n/**\n * Process itinerary transitions\n */\nfunction processPhaseTransition(store: LogStore, plan: Plan, entry: LogEntry, ts: Date): void {\n  const currentPhase = entry['current phase'];\n  const nextPhase = entry['next phase'];\n\n  if (!currentPhase || !nextPhase) return;\n\n  store.addEvent({\n    timestamp: entry.ts,\n    type: 'phase_transition',\n    planName: plan.name,\n    namespace: plan.namespace,\n    description: `${currentPhase}  ${nextPhase}`,\n    phase: nextPhase,\n  });\n\n  // If transitioning to Completed, update all VMs\n  if (nextPhase === Phases.Completed) {\n    for (const vm of Object.values(plan.vms)) {\n      if (vm.currentPhase !== Phases.Completed) {\n        // Close previous phase\n        if (vm.phaseHistory.length > 0) {\n          const lastPhase = vm.phaseHistory[vm.phaseHistory.length - 1];\n          if (!lastPhase.endedAt) {\n            lastPhase.endedAt = ts;\n          }\n        }\n        vm.currentPhase = Phases.Completed;\n        vm.phaseHistory.push({\n          name: Phases.Completed,\n          step: '',\n          startedAt: ts,\n          endedAt: ts,\n        });\n      }\n    }\n    plan.status = PlanStatuses.Succeeded;\n  }\n}\n\n/**\n * Process condition additions\n */\nfunction processConditionAdded(store: LogStore, plan: Plan, entry: LogEntry, ts: Date): void {\n  if (!entry.condition) return;\n\n  const condType = getStringFromMap(entry.condition, 'type');\n  const condStatus = getStringFromMap(entry.condition, 'status');\n  const condMessage = getStringFromMap(entry.condition, 'message');\n  const condCategory = getStringFromMap(entry.condition, 'category');\n\n  const cond: Condition = {\n    type: condType,\n    status: condStatus,\n    category: condCategory,\n    message: condMessage,\n    timestamp: ts,\n  };\n\n  // Update plan status based on condition\n  if (condType === 'Executing' && condStatus === ConditionStatus.True) {\n    plan.status = PlanStatuses.Running;\n  } else if (condType === 'Ready' && condStatus === ConditionStatus.True && plan.status === PlanStatuses.Pending) {\n    plan.status = PlanStatuses.Ready;\n  } else if (condType === 'Succeeded' && condStatus === ConditionStatus.True) {\n    plan.status = PlanStatuses.Succeeded;\n  } else if (condType === 'Failed' && condStatus === ConditionStatus.True) {\n    plan.status = PlanStatuses.Failed;\n  }\n\n  // Add or update condition\n  const existingIdx = plan.conditions.findIndex(c => c.type === condType);\n  if (existingIdx >= 0) {\n    plan.conditions[existingIdx] = cond;\n  } else {\n    plan.conditions.push(cond);\n  }\n\n  store.addEvent({\n    timestamp: entry.ts,\n    type: 'condition',\n    planName: plan.name,\n    namespace: plan.namespace,\n    description: `${condType}: ${condMessage}`,\n  });\n}\n\n/**\n * Process condition deletions\n */\nfunction processConditionDeleted(plan: Plan, entry: LogEntry): void {\n  if (!entry.condition) return;\n\n  const condType = getStringFromMap(entry.condition, 'type');\n  plan.conditions = plan.conditions.filter(c => c.type !== condType);\n}\n\n/**\n * Process DataVolume creation\n */\nfunction processDataVolume(plan: Plan, entry: LogEntry, ts: Date): void {\n  const { id: vmID } = getVMInfo(entry);\n  if (!vmID) return;\n\n  const vm = plan.vms[vmID];\n  if (!vm) return;\n\n  vm.dataVolumes.push({\n    name: entry.dv!,\n    createdAt: ts,\n  });\n\n  // Store raw log entry for CreateDataVolumes phase\n  const rawLogEntry: RawLogEntry = {\n    timestamp: entry.ts,\n    level: entry.level,\n    message: `${entry.msg} (${entry.dv})`,\n    phase: 'CreateDataVolumes',\n    rawLine: entry.rawLine || '',\n  };\n\n  if (!vm.phaseLogs['CreateDataVolumes']) {\n    vm.phaseLogs['CreateDataVolumes'] = [];\n  }\n  vm.phaseLogs['CreateDataVolumes'].push(rawLogEntry);\n}\n\n/**\n * Process created resources (VMs, Pods, Secrets, ConfigMaps, etc.)\n */\nfunction processCreatedResource(plan: Plan, entry: LogEntry, ts: Date, msg: string): void {\n  const { id: vmID } = getVMInfo(entry);\n  if (!vmID) return;\n\n  const vm = plan.vms[vmID];\n  if (!vm) return;\n\n  let resourceType = '';\n  let resourceName = '';\n\n  // Handle specific resource creation messages\n  // Cast entry to unknown first, then to Record for accessing dynamic fields\n  const entryRecord = entry as unknown as Record<string, unknown>;\n  \n  // \"Secret created.\" with 'secret' field\n  if (msg === 'Secret created.' && entryRecord.secret) {\n    resourceType = 'Secret';\n    resourceName = entryRecord.secret as string;\n  }\n  // \"ConfigMap created.\" with 'configMap' field\n  else if (msg === 'ConfigMap created.' && entryRecord.configMap) {\n    resourceType = 'ConfigMap';\n    resourceName = entryRecord.configMap as string;\n  }\n  // \"Pod created.\" with 'pod' field\n  else if (msg === 'Pod created.' && entryRecord.pod) {\n    resourceType = 'Pod';\n    resourceName = entryRecord.pod as string;\n  }\n  // \"VirtualMachine created.\" with 'virtualMachine' field\n  else if (msg === 'VirtualMachine created.' && entryRecord.virtualMachine) {\n    resourceType = 'VirtualMachine';\n    resourceName = entryRecord.virtualMachine as string;\n  }\n  // \"PVC created.\" with 'pvc' field\n  else if (msg === 'PVC created.' && entryRecord.pvc) {\n    resourceType = 'PVC';\n    resourceName = entryRecord.pvc as string;\n  }\n  // Generic \"Created X.\" format\n  else {\n    const resourceMatch = msg.match(/^Created (\\w+)\\.?$/);\n    if (resourceMatch) {\n      resourceType = resourceMatch[1];\n      // Skip DataVolumes as they're handled separately\n      if (resourceType === 'DataVolume') return;\n      \n      // Get resource name from the 'object' field if available\n      if (entry.object?.name) {\n        resourceName = entry.object.namespace \n          ? `${entry.object.namespace}/${entry.object.name}`\n          : entry.object.name;\n      }\n    }\n  }\n\n  if (!resourceType) return;\n\n  // Check if this resource is already tracked (avoid duplicates)\n  const exists = vm.createdResources.some(\n    r => r.type === resourceType && r.name === resourceName\n  );\n  \n  if (!exists) {\n    vm.createdResources.push({\n      type: resourceType,\n      name: resourceName,\n      createdAt: ts,\n    });\n  }\n}\n\n/**\n * Process error-level log entries\n */\nfunction processErrorLog(\n  store: LogStore,\n  plan: Plan,\n  planName: string,\n  namespace: string,\n  entry: LogEntry,\n  ts: Date\n): void {\n  const msg = entry.msg || '';\n\n  // Ignore transient startup errors\n  if (entry.error?.includes('connection refused')) {\n    return;\n  }\n\n  // Mark as failed for Reconcile failed errors\n  if (msg.includes('Reconcile failed')) {\n    plan.status = PlanStatuses.Failed;\n  }\n\n  // Get VM name if available\n  const { name: vmName } = getVMInfo(entry);\n\n  // Build message with VM name if available\n  let fullMsg = msg;\n  if (vmName) {\n    fullMsg = `[${vmName}] ${msg}`;\n  }\n\n  // Check if this error already exists (group identical errors)\n  const existingIdx = plan.errors.findIndex(\n    e => e.error === entry.error && e.message === fullMsg\n  );\n\n  if (existingIdx >= 0) {\n    plan.errors[existingIdx].count++;\n    plan.errors[existingIdx].timestamp = ts;\n  } else {\n    plan.errors.push({\n      timestamp: ts,\n      message: fullMsg,\n      error: entry.error || '',\n      stacktrace: entry.stacktrace,\n      rawLine: entry.rawLine,\n      count: 1,\n      level: 'error',\n    });\n  }\n\n  store.addEvent({\n    timestamp: entry.ts,\n    type: 'error',\n    planName,\n    namespace,\n    vmName,\n    description: truncate(`${fullMsg}: ${entry.error}`, 150),\n  });\n}\n\n/**\n * Process warning-level log entries\n */\nfunction processWarningLog(\n  store: LogStore,\n  plan: Plan,\n  planName: string,\n  namespace: string,\n  entry: LogEntry,\n  ts: Date\n): void {\n  const { name: vmName } = getVMInfo(entry);\n\n  const errorMsg = entry.err || '';\n  let fullMsg = entry.msg || '';\n  if (vmName) {\n    fullMsg = `[${vmName}] ${entry.msg}`;\n  }\n\n  // Check if this error already exists\n  const existingIdx = plan.errors.findIndex(e => e.error === errorMsg);\n\n  if (existingIdx >= 0) {\n    plan.errors[existingIdx].count++;\n    plan.errors[existingIdx].timestamp = ts;\n  } else {\n    plan.errors.push({\n      timestamp: ts,\n      message: fullMsg,\n      error: errorMsg,\n      rawLine: entry.rawLine,\n      count: 1,\n      level: 'warning',\n    });\n  }\n\n  store.addEvent({\n    timestamp: entry.ts,\n    type: 'warning',\n    planName,\n    namespace,\n    vmName,\n    description: truncate(`${fullMsg}: ${errorMsg}`, 150),\n  });\n}\n\n/**\n * Store log entry under VM's current phase\n */\nexport function storeVMLog(plan: Plan, entry: LogEntry): void {\n  const { id: vmID } = getVMInfo(entry);\n  if (!vmID) return;\n\n  const vm = plan.vms[vmID];\n  if (!vm || !vm.currentPhase) return;\n\n  // Determine which phase to store under\n  const phase = entry.phase || vm.currentPhase;\n\n  const rawLogEntry: RawLogEntry = {\n    timestamp: entry.ts,\n    level: entry.level,\n    message: entry.msg || '',\n    phase,\n    rawLine: entry.rawLine || '',\n  };\n\n  if (!vm.phaseLogs[phase]) {\n    vm.phaseLogs[phase] = [];\n  }\n  vm.phaseLogs[phase].push(rawLogEntry);\n}\n\n/**\n * Detect storage offload (VSphereXcopy) from a log entry.\n * Signals:\n *   - \"Creating pvc\" with dataSourceRef.kind === \"VSphereXcopyVolumePopulator\"\n *     or annotations containing \"copy-offload\" / \"xcopy\"\n *   - \"Creating the populator resource\" with a VSphereXcopyVolumePopulator key\n *   - Any message referencing VSphereXcopyVolumePopulator / VSphereXcopyPopulator\n *   - Messages about \"populator CR\" (Deleting / Deleted / Successfully deleted)\n */\nfunction detectStorageOffload(entry: LogEntry): boolean {\n  const msg = entry.msg || '';\n  const raw = entry.rawLine || '';\n\n  // Fast check: look for known keywords anywhere in the raw line\n  if (raw.includes('VSphereXcopy') || raw.includes('copy-offload') || raw.includes('xcopy-initial-offload')) {\n    return true;\n  }\n\n  // \"Creating the populator resource\" message\n  if (msg === 'Creating the populator resource') {\n    return true;\n  }\n\n  // Messages mentioning populator CR\n  if (msg.includes('populator CR') || msg.includes('Populator CR')) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Mark the VM (or all VMs in the plan) as using storage offload.\n */\nfunction markVMStorageOffload(plan: Plan, entry: LogEntry): void {\n  const { id: vmID } = getVMInfo(entry);\n  if (vmID) {\n    const vm = plan.vms[vmID];\n    if (vm) {\n      vm.transferMethod = 'StorageOffload';\n    }\n  }\n}\n\n","import type { LogEntry, Plan } from '../types';\nimport { LogStore } from './LogStore';\nimport { PlanStatuses, PanicPrefix } from './constants';\nimport { truncate } from './utils';\n\n/**\n * Process panic observer log entries\n */\nexport function processPanicLog(store: LogStore, entry: LogEntry, ts: Date): void {\n  // Extract plan info from object field\n  const planName = entry.object?.name || '';\n  const namespace = entry.object?.namespace || '';\n\n  if (!planName || !namespace) return;\n\n  const plan = store.getOrCreatePlan(namespace, planName);\n  plan.status = PlanStatuses.Failed;\n\n  // Extract panic message - prefer the 'panic' field, fall back to parsing the message\n  let panicMsg = entry.panic || '';\n  if (!panicMsg) {\n    panicMsg = entry.msg || '';\n    const idx = panicMsg.indexOf(': ');\n    if (idx > 0) {\n      panicMsg = panicMsg.slice(idx + 2);\n    }\n  }\n\n  // Get stacktrace from the entry\n  const stacktrace = entry.stacktrace || '';\n\n  // Check if this panic already exists (group identical panics)\n  const existingIdx = plan.panics.findIndex(p => p.message === panicMsg);\n\n  if (existingIdx >= 0) {\n    plan.panics[existingIdx].count++;\n    plan.panics[existingIdx].timestamp = ts;\n    plan.panics[existingIdx].rawLines?.push(entry.rawLine || '');\n    // Update stacktrace if we have a better one\n    if (stacktrace && stacktrace.length > (plan.panics[existingIdx].stacktrace?.length || 0)) {\n      plan.panics[existingIdx].stacktrace = stacktrace;\n    }\n  } else {\n    plan.panics.push({\n      timestamp: ts,\n      message: panicMsg,\n      controller: entry.controller,\n      reconcileId: entry.reconcileID,\n      stacktrace,\n      rawLines: entry.rawLine ? [entry.rawLine] : [],\n      count: 1,\n    });\n  }\n\n  store.addEvent({\n    timestamp: entry.ts,\n    type: 'panic',\n    planName,\n    namespace,\n    description: `Panic: ${truncate(panicMsg, 100)}`,\n  });\n}\n\n/**\n * Process reconciler error log entries (often follows a panic)\n */\nexport function processReconcilerError(store: LogStore, entry: LogEntry, ts: Date): void {\n  // Extract plan info from object field\n  const planName = entry.object?.name || '';\n  const namespace = entry.object?.namespace || '';\n\n  if (!planName || !namespace) return;\n\n  const plan = store.getOrCreatePlan(namespace, planName);\n\n  // Check if this is a recovered panic error\n  if (entry.error?.includes(PanicPrefix)) {\n    plan.status = PlanStatuses.Failed;\n\n    // Extract the panic message from the error\n    let panicMsg = entry.error;\n    const panicIdx = panicMsg.indexOf('panic: ');\n    if (panicIdx >= 0) {\n      panicMsg = panicMsg.slice(panicIdx + 7);\n      const recoveredIdx = panicMsg.indexOf(' [recovered]');\n      if (recoveredIdx > 0) {\n        panicMsg = panicMsg.slice(0, recoveredIdx);\n      }\n    }\n\n    // Check if we already have this panic recorded\n    for (let i = 0; i < plan.panics.length; i++) {\n      const existingPanic = plan.panics[i];\n      if (existingPanic.message.includes(panicMsg) || panicMsg.includes(existingPanic.message)) {\n        plan.panics[i].rawLines?.push(entry.rawLine || '');\n        // Add stacktrace if we have one and it's different\n        if (entry.stacktrace && entry.stacktrace !== existingPanic.stacktrace) {\n          if (existingPanic.stacktrace) {\n            plan.panics[i].stacktrace = `${existingPanic.stacktrace}\\n\\n--- Recovery Stacktrace ---\\n${entry.stacktrace}`;\n          } else {\n            plan.panics[i].stacktrace = entry.stacktrace;\n          }\n        }\n        return;\n      }\n    }\n\n    // If no matching panic found, create a new entry\n    plan.panics.push({\n      timestamp: ts,\n      message: panicMsg,\n      controller: entry.controller,\n      reconcileId: entry.reconcileID,\n      stacktrace: entry.stacktrace,\n      rawLines: entry.rawLine ? [entry.rawLine] : [],\n      count: 1,\n    });\n  }\n}\n\n/**\n * Save raw panic stack trace lines to the most recent panic\n */\nexport function savePanicStacktrace(plan: Plan, lines: string[]): void {\n  if (!plan || lines.length === 0) return;\n\n  const stacktrace = lines.join('\\n');\n\n  // Try to find the most recent panic entry for this plan\n  if (plan.panics.length > 0) {\n    const lastIdx = plan.panics.length - 1;\n    plan.panics[lastIdx].stacktrace = stacktrace;\n    plan.panics[lastIdx].rawLines = [\n      ...(plan.panics[lastIdx].rawLines || []),\n      ...lines,\n    ];\n  } else {\n    // Create a new panic entry for orphaned stack trace\n    let panicMsg = 'Unknown panic';\n    if (lines.length > 0 && lines[0].startsWith('panic: ')) {\n      panicMsg = lines[0].slice(7);\n    }\n    plan.panics.push({\n      timestamp: plan.lastSeen,\n      message: panicMsg,\n      stacktrace,\n      rawLines: lines,\n      count: 1,\n    });\n    plan.status = PlanStatuses.Failed;\n  }\n}\n","import type { LogEntry, Plan, ParsedData, ScheduleSnapshot } from '../types';\nimport { LogStore } from './LogStore';\nimport { ContainerLogPrefixRegex } from './constants';\nimport { parseTimestamp, isPanicLine } from './utils';\nimport { processPlanLog } from './planProcessor';\nimport { processPanicLog, processReconcilerError, savePanicStacktrace } from './panicProcessor';\n\n/**\n * Parse log file content and return structured data\n */\nexport function parseLogFile(content: string): ParsedData {\n  const store = new LogStore();\n  const lines = content.split('\\n');\n\n  // Track panic context\n  let currentPanicPlan: Plan | undefined;\n  let currentPanicLines: string[] = [];\n  let inPanicStacktrace = false;\n\n  for (const line of lines) {\n    store.incrementStat('totalLines');\n\n    if (!line.trim()) continue;\n\n    // Skip duplicate lines\n    if (store.isLineProcessed(line)) {\n      store.incrementStat('duplicateLines');\n      continue;\n    }\n\n    // Check for container log format (timestamp prefix followed by JSON)\n    let jsonContent = line;\n    let containerTimestamp = '';\n    const matches = line.match(ContainerLogPrefixRegex);\n    if (matches) {\n      containerTimestamp = matches[1];\n      jsonContent = matches[2];\n    }\n\n    // Try to parse as JSON\n    let entry: LogEntry;\n    try {\n      const parsed = JSON.parse(jsonContent);\n      // JSON.parse can return primitives (numbers, strings, booleans, null).\n      // We only care about object log entries.\n      if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {\n        store.incrementStat('errorLines');\n        continue;\n      }\n      entry = parsed;\n    } catch {\n      // Non-JSON line - could be part of panic stack trace\n      if (inPanicStacktrace || isPanicLine(line)) {\n        inPanicStacktrace = true;\n        currentPanicLines.push(line);\n\n        // Check if this looks like the start of a panic\n        if (line.startsWith('panic:') && !currentPanicPlan) {\n          currentPanicPlan = store.getMostRecentPlan();\n        }\n      }\n      store.incrementStat('errorLines');\n      continue;\n    }\n\n    // If JSON didn't have a timestamp but we extracted one from container log prefix\n    if (!entry.ts && containerTimestamp) {\n      entry.ts = containerTimestamp;\n    }\n\n    // If we were collecting panic lines and hit a new JSON entry, save the panic\n    if (inPanicStacktrace && currentPanicPlan && currentPanicLines.length > 0) {\n      savePanicStacktrace(currentPanicPlan, currentPanicLines);\n      currentPanicLines = [];\n      currentPanicPlan = undefined;\n      inPanicStacktrace = false;\n    }\n\n    // Store raw line\n    entry.rawLine = line;\n\n    // Mark line as processed\n    store.markLineProcessed(line);\n\n    store.incrementStat('parsedLines');\n    processEntry(store, entry);\n  }\n\n  // Save any remaining panic lines\n  if (inPanicStacktrace && currentPanicPlan && currentPanicLines.length > 0) {\n    savePanicStacktrace(currentPanicPlan, currentPanicLines);\n  }\n\n  return store.getResult();\n}\n\n/**\n * Process a single log entry\n */\nfunction processEntry(store: LogStore, entry: LogEntry): void {\n  const ts = parseTimestamp(entry.ts);\n\n  // Check for panic log (controller-runtime panic observer)\n  if (entry.msg?.includes('Observed a panic')) {\n    processPanicLog(store, entry, ts);\n    return;\n  }\n\n  // Check for reconciler error (often follows a panic)\n  if (entry.msg === 'Reconciler error' && entry.controller) {\n    processReconcilerError(store, entry, ts);\n    return;\n  }\n\n  // Check if this is a plan-related log\n  if (entry.logger?.startsWith('plan|')) {\n    processPlanLog(store, entry, ts);\n    return;\n  }\n\n  // Check for scheduler logs (snapshot of inflight/pending VMs)\n  if (entry.msg?.includes('scheduler') || entry.logger?.includes('scheduler')) {\n    processSchedulerLog(store, entry, ts);\n    return;\n  }\n}\n\n/**\n * Process scheduler log entries to capture scheduling snapshots\n */\nfunction processSchedulerLog(store: LogStore, entry: LogEntry, ts: Date): void {\n  // Look for structured scheduler data in the log entry\n  const entryAny = entry as unknown as Record<string, unknown>;\n  const inflight = entryAny.inflight as Record<string, { id?: string; name?: string }[]> | undefined;\n  const pending = entryAny.pending as Record<string, { id?: string; name?: string }[]> | undefined;\n\n  if (!inflight && !pending) return;\n\n  const snapshot: ScheduleSnapshot = {\n    timestamp: ts.toISOString(),\n    inflight: inflight || {},\n    pending: pending || {},\n  };\n\n  // Check for next VM info\n  const nextVM = entryAny.next as { id?: string; name?: string } | undefined;\n  if (nextVM) {\n    snapshot.nextVM = nextVM;\n  }\n\n  // Try to associate with a plan from the logger (e.g., \"scheduler|ns/plan\")\n  const loggerParts = entry.logger?.split('|');\n  if (loggerParts && loggerParts.length >= 2) {\n    const planRef = loggerParts[1];\n    const plan = store.findPlan(planRef);\n    if (plan) {\n      if (!plan.scheduleHistory) {\n        plan.scheduleHistory = [];\n      }\n      plan.scheduleHistory.push(snapshot);\n    }\n  }\n}\n\nexport { LogStore };\n","\n/*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT */\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nvar isNothing_1      = isNothing;\nvar isObject_1       = isObject;\nvar toArray_1        = toArray;\nvar repeat_1         = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1         = extend;\n\nvar common = {\n\tisNothing: isNothing_1,\n\tisObject: isObject_1,\n\ttoArray: toArray_1,\n\trepeat: repeat_1,\n\tisNegativeZero: isNegativeZero_1,\n\textend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException$1(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\n\n\nYAMLException$1.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nvar exception = YAMLException$1;\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nvar snippet = makeSnippet;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type$1(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type$1;\n\n/*eslint-disable max-len*/\n\n\n\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema$1(definition) {\n  return this.extend(definition);\n}\n\n\nSchema$1.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type$1.multi) {\n      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema$1.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nvar schema = Schema$1;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\nvar failsafe = new schema({\n  explicit: [\n    str,\n    seq,\n    map\n  ]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = failsafe.extend({\n  implicit: [\n    _null,\n    bool,\n    int,\n    float\n  ]\n});\n\nvar core = json;\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n/*eslint-disable no-bitwise*/\n\n\n\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString$2.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty$3.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$2.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar _default = core.extend({\n  implicit: [\n    timestamp,\n    merge\n  ],\n  explicit: [\n    binary,\n    omap,\n    pairs,\n    set\n  ]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\n// set a property of a literal object, while protecting against prototype pollution,\n// see https://github.com/nodeca/js-yaml/issues/164 for more details\nfunction setProperty(object, key, value) {\n  // used for this specific key only because Object.defineProperty is slow\n  if (key === '__proto__') {\n    Object.defineProperty(object, key, {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State$1(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || _default;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = snippet(mark);\n\n  return new exception(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$1.call(destination, key)) {\n      setProperty(destination, key, source[key]);\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\n        _hasOwnProperty$1.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    setProperty(_result, keyNode, valueNode);\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State$1(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll$1(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load$1(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new exception('expected a single document in the stream, but found more');\n}\n\n\nvar loadAll_1 = loadAll$1;\nvar load_1    = load$1;\n\nvar loader = {\n\tloadAll: loadAll_1,\n\tload: load_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\n\n\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || _default;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnt mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out\n//                             c = flow-in    ns-plain-safe-in\n//                             c = block-key  ns-plain-safe-out\n//                             c = flow-key   ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )\n//                            | ( /* An ns-char preceding */ # )\n//                            | ( : /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // - | ? | : | , | [ | ] | { | }\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | # | & | * | ! | | | = | > | ' | \"\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | % | @ | `)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//     No ending newline => unaffected; already using strip \"-\" chomping.\n//     Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -\n      // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #\n      //                         | ; | / | ? | : | @ | & | = | + | $ | ,\n      //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump$1(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nvar dump_1 = dump$1;\n\nvar dumper = {\n\tdump: dump_1\n};\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nvar Type                = type;\nvar Schema              = schema;\nvar FAILSAFE_SCHEMA     = failsafe;\nvar JSON_SCHEMA         = json;\nvar CORE_SCHEMA         = core;\nvar DEFAULT_SCHEMA      = _default;\nvar load                = loader.load;\nvar loadAll             = loader.loadAll;\nvar dump                = dumper.dump;\nvar YAMLException       = exception;\n\n// Re-export all types in case user wants to create custom schema\nvar types = {\n  binary:    binary,\n  float:     float,\n  map:       map,\n  null:      _null,\n  pairs:     pairs,\n  set:       set,\n  timestamp: timestamp,\n  bool:      bool,\n  int:       int,\n  merge:     merge,\n  omap:      omap,\n  seq:       seq,\n  str:       str\n};\n\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad            = renamed('safeLoad', 'load');\nvar safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nvar safeDump            = renamed('safeDump', 'dump');\n\nvar jsYaml = {\n\tType: Type,\n\tSchema: Schema,\n\tFAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n\tJSON_SCHEMA: JSON_SCHEMA,\n\tCORE_SCHEMA: CORE_SCHEMA,\n\tDEFAULT_SCHEMA: DEFAULT_SCHEMA,\n\tload: load,\n\tloadAll: loadAll,\n\tdump: dump,\n\tYAMLException: YAMLException,\n\ttypes: types,\n\tsafeLoad: safeLoad,\n\tsafeLoadAll: safeLoadAll,\n\tsafeDump: safeDump\n};\n\nexport { CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema, Type, YAMLException, jsYaml as default, dump, load, loadAll, safeDump, safeLoad, safeLoadAll, types };\n","import yaml from 'js-yaml';\nimport type { Plan, PlanSpec, VM, VMError, PhaseInfo, Condition, ParsedData, ParseStats, Summary, PhaseLogSummary, RawLogEntry, MigrationType, WarmInfo, PrecopyInfo, NetworkMapResource, StorageMapResource, NetworkMapEntry, StorageMapEntry, MapReference } from '../types';\nimport { PlanStatuses, MigrationTypes, PipelineSteps, Phases, ConditionStatus, phaseToStep } from './constants';\nimport { formatDuration, groupLogs } from './utils';\n\n// Types for the raw YAML structures\ninterface YamlPlanResource {\n  apiVersion?: string;\n  kind?: string;\n  metadata?: {\n    name?: string;\n    namespace?: string;\n    creationTimestamp?: string;\n    uid?: string;\n  };\n  spec?: {\n    description?: string;\n    type?: string;\n    warm?: boolean;\n    vms?: Array<{ id?: string; name?: string }>;\n    targetNamespace?: string;\n    archived?: boolean;\n    preserveStaticIPs?: boolean;\n    skipGuestConversion?: boolean;\n    useCompatibilityMode?: boolean;\n    runPreflightInspection?: boolean;\n    targetPowerState?: string;\n    migrateSharedDisks?: boolean;\n    pvcNameTemplateUseGenerateName?: boolean;\n    preserveClusterCpuModel?: boolean;\n    deleteGuestConversionPod?: boolean;\n    deleteVmOnFailMigration?: boolean;\n    installLegacyDrivers?: boolean;\n    transferNetwork?: { name?: string; namespace?: string };\n    provider?: {\n      source?: { name?: string };\n      destination?: { name?: string };\n    };\n    map?: {\n      network?: { name?: string };\n      storage?: { name?: string };\n    };\n  };\n  status?: {\n    conditions?: YamlCondition[];\n    observedGeneration?: number;\n    migration?: {\n      started?: string;\n      completed?: string;\n      vms?: YamlVMStatus[];\n      history?: unknown[];\n    };\n  };\n}\n\ninterface YamlCondition {\n  type?: string;\n  status?: string;\n  category?: string;\n  message?: string;\n  lastTransitionTime?: string;\n  durable?: boolean;\n}\n\ninterface YamlPipelineStep {\n  name?: string;\n  description?: string;\n  phase?: string;\n  started?: string;\n  completed?: string;\n  progress?: { completed?: number; total?: number };\n  annotations?: Record<string, string>;\n  tasks?: YamlTask[];\n  error?: {\n    phase?: string;\n    reasons?: string[];\n  };\n}\n\ninterface YamlTask {\n  name?: string;\n  phase?: string;\n  started?: string;\n  completed?: string;\n  reason?: string;\n  progress?: { completed?: number; total?: number };\n  annotations?: Record<string, string>;\n}\n\ninterface YamlPrecopy {\n  snapshot?: string;\n  start?: string;\n  end?: string;\n  createTaskId?: string;\n  removeTaskId?: string;\n  deltas?: Array<{\n    deltaId?: string;\n    disk?: string;\n  }>;\n}\n\ninterface YamlVMStatus {\n  id?: string;\n  name?: string;\n  newName?: string;\n  phase?: string;\n  started?: string;\n  completed?: string;\n  operatingSystem?: string;\n  restorePowerState?: string;\n  conditions?: YamlCondition[];\n  pipeline?: YamlPipelineStep[];\n  warm?: {\n    precopies?: YamlPrecopy[];\n    successes?: number;\n    failures?: number;\n    consecutiveFailures?: number;\n    nextPrecopyAt?: string;\n  };\n  error?: {\n    phase?: string;\n    reasons?: string[];\n  };\n  luks?: Record<string, unknown>;\n}\n\ninterface YamlKubernetesList {\n  apiVersion?: string;\n  kind?: string;\n  items?: YamlPlanResource[];\n  metadata?: unknown;\n}\n\ninterface YamlMapResource {\n  apiVersion?: string;\n  kind?: string;\n  metadata?: {\n    name?: string;\n    namespace?: string;\n    ownerReferences?: Array<{ kind?: string; name?: string }>;\n  };\n  spec?: {\n    map?: Array<{\n      source?: { id?: string; name?: string };\n      destination?: { type?: string; name?: string; namespace?: string; storageClass?: string; accessMode?: string; volumeMode?: string };\n    }>;\n    provider?: {\n      source?: { name?: string; namespace?: string };\n      destination?: { name?: string; namespace?: string };\n    };\n  };\n  status?: {\n    conditions?: YamlCondition[];\n    references?: Array<{ id?: string; name?: string }>;\n  };\n}\n\n/**\n * Check if content looks like YAML (not JSON log lines)\n */\nexport function isYamlContent(content: string): boolean {\n  const trimmed = content.trim();\n  if (trimmed.startsWith('{') || trimmed.startsWith('[')) return false;\n  if (trimmed.includes('apiVersion:') && trimmed.includes('kind:')) return true;\n  if (trimmed.startsWith('---')) return true;\n  return false;\n}\n\n/**\n * Parse Plan YAML content and return structured data\n */\nexport function parsePlanYaml(content: string): ParsedData {\n  try {\n    return parsePlanYamlImpl(content);\n  } catch (err) {\n    console.error('parsePlanYaml failed:', err);\n    return {\n      plans: [],\n      events: [],\n      stats: {\n        totalLines: content.split('\\n').length,\n        parsedLines: 0,\n        errorLines: 0,\n        duplicateLines: 0,\n        plansFound: 0,\n        vmsFound: 0,\n      },\n      summary: {\n        totalPlans: 0,\n        running: 0,\n        succeeded: 0,\n        failed: 0,\n        archived: 0,\n        pending: 0,\n      },\n      networkMaps: [],\n      storageMaps: [],\n    };\n  }\n}\n\nfunction parsePlanYamlImpl(content: string): ParsedData {\n  const docs = yaml.loadAll(content) as unknown[];\n\n  const planResources: YamlPlanResource[] = [];\n  const networkMapResources: YamlMapResource[] = [];\n  const storageMapResources: YamlMapResource[] = [];\n\n  for (const doc of docs) {\n    if (!doc || typeof doc !== 'object') continue;\n    const obj = doc as Record<string, unknown>;\n\n    if (obj.kind === 'PlanList' || obj.kind === 'List') {\n      const list = doc as YamlKubernetesList;\n      if (list.items && Array.isArray(list.items)) {\n        for (const item of list.items) {\n          if (isPlanResource(item)) {\n            planResources.push(item);\n          }\n        }\n      }\n      continue;\n    }\n\n    if (obj.kind === 'NetworkMapList') {\n      const list = doc as { items?: YamlMapResource[] };\n      if (list.items && Array.isArray(list.items)) {\n        for (const item of list.items) {\n          if (isNetworkMapResource(item)) {\n            networkMapResources.push(item as YamlMapResource);\n          }\n        }\n      }\n      continue;\n    }\n\n    if (obj.kind === 'StorageMapList') {\n      const list = doc as { items?: YamlMapResource[] };\n      if (list.items && Array.isArray(list.items)) {\n        for (const item of list.items) {\n          if (isStorageMapResource(item)) {\n            storageMapResources.push(item as YamlMapResource);\n          }\n        }\n      }\n      continue;\n    }\n\n    if (isPlanResource(doc)) {\n      planResources.push(doc as YamlPlanResource);\n    } else if (isNetworkMapResource(doc)) {\n      networkMapResources.push(doc as YamlMapResource);\n    } else if (isStorageMapResource(doc)) {\n      storageMapResources.push(doc as YamlMapResource);\n    }\n  }\n\n  const plans: Plan[] = planResources.map(convertPlanResource);\n  const networkMaps: NetworkMapResource[] = networkMapResources.map(convertNetworkMapResource);\n  const storageMaps: StorageMapResource[] = storageMapResources.map(convertStorageMapResource);\n\n  const stats: ParseStats = {\n    totalLines: content.split('\\n').length,\n    parsedLines: content.split('\\n').length,\n    errorLines: 0,\n    duplicateLines: 0,\n    plansFound: plans.length,\n    vmsFound: plans.reduce((sum, p) => sum + Object.keys(p.vms).length, 0),\n  };\n\n  const summary: Summary = {\n    totalPlans: plans.length,\n    running: plans.filter(p => p.status === PlanStatuses.Running).length,\n    succeeded: plans.filter(p => p.status === PlanStatuses.Succeeded).length,\n    failed: plans.filter(p => p.status === PlanStatuses.Failed).length,\n    archived: plans.filter(p => p.archived).length,\n    pending: plans.filter(p => p.status === PlanStatuses.Pending || p.status === PlanStatuses.Ready).length,\n  };\n\n  return { plans, events: [], summary, stats, networkMaps, storageMaps };\n}\n\nfunction isPlanResource(obj: unknown): boolean {\n  if (!obj || typeof obj !== 'object') return false;\n  const o = obj as Record<string, unknown>;\n  return o.kind === 'Plan' && typeof o.apiVersion === 'string' &&\n    (o.apiVersion as string).startsWith('forklift.konveyor.io/');\n}\n\nfunction isNetworkMapResource(obj: unknown): boolean {\n  if (!obj || typeof obj !== 'object') return false;\n  const o = obj as Record<string, unknown>;\n  return o.kind === 'NetworkMap' && typeof o.apiVersion === 'string' &&\n    (o.apiVersion as string).startsWith('forklift.konveyor.io/');\n}\n\nfunction isStorageMapResource(obj: unknown): boolean {\n  if (!obj || typeof obj !== 'object') return false;\n  const o = obj as Record<string, unknown>;\n  return o.kind === 'StorageMap' && typeof o.apiVersion === 'string' &&\n    (o.apiVersion as string).startsWith('forklift.konveyor.io/');\n}\n\nfunction convertNetworkMapResource(resource: YamlMapResource): NetworkMapResource {\n  const name = resource.metadata?.name || 'unknown';\n  const namespace = resource.metadata?.namespace || 'default';\n\n  const ownerPlanName = resource.metadata?.ownerReferences\n    ?.find(ref => ref.kind === 'Plan')?.name;\n\n  const entries: NetworkMapEntry[] = (resource.spec?.map || []).map(entry => ({\n    source: { id: entry.source?.id, name: entry.source?.name },\n    destination: { type: entry.destination?.type, name: entry.destination?.name, namespace: entry.destination?.namespace },\n  }));\n\n  const provider = resource.spec?.provider ? {\n    source: resource.spec.provider.source ? { name: resource.spec.provider.source.name, namespace: resource.spec.provider.source.namespace } : undefined,\n    destination: resource.spec.provider.destination ? { name: resource.spec.provider.destination.name, namespace: resource.spec.provider.destination.namespace } : undefined,\n  } : undefined;\n\n  const conditions: Condition[] = (resource.status?.conditions || []).map(c => ({\n    type: c.type || '',\n    status: c.status || '',\n    category: c.category,\n    message: c.message || '',\n    timestamp: new Date(c.lastTransitionTime || 0),\n  }));\n\n  const references: MapReference[] | undefined = resource.status?.references?.map(r => ({\n    id: r.id || '',\n    name: r.name || '',\n  }));\n\n  return { name, namespace, ownerPlanName, entries, provider, conditions, references };\n}\n\nfunction convertStorageMapResource(resource: YamlMapResource): StorageMapResource {\n  const name = resource.metadata?.name || 'unknown';\n  const namespace = resource.metadata?.namespace || 'default';\n\n  const ownerPlanName = resource.metadata?.ownerReferences\n    ?.find(ref => ref.kind === 'Plan')?.name;\n\n  const entries: StorageMapEntry[] = (resource.spec?.map || []).map(entry => ({\n    source: { id: entry.source?.id, name: entry.source?.name },\n    destination: {\n      storageClass: entry.destination?.storageClass,\n      accessMode: entry.destination?.accessMode,\n      volumeMode: entry.destination?.volumeMode,\n      name: entry.destination?.name,\n    },\n  }));\n\n  const provider = resource.spec?.provider ? {\n    source: resource.spec.provider.source ? { name: resource.spec.provider.source.name, namespace: resource.spec.provider.source.namespace } : undefined,\n    destination: resource.spec.provider.destination ? { name: resource.spec.provider.destination.name, namespace: resource.spec.provider.destination.namespace } : undefined,\n  } : undefined;\n\n  const conditions: Condition[] = (resource.status?.conditions || []).map(c => ({\n    type: c.type || '',\n    status: c.status || '',\n    category: c.category,\n    message: c.message || '',\n    timestamp: new Date(c.lastTransitionTime || 0),\n  }));\n\n  return { name, namespace, ownerPlanName, entries, provider, conditions };\n}\n\nfunction convertPlanResource(resource: YamlPlanResource): Plan {\n  const name = resource.metadata?.name || 'unknown';\n  const namespace = resource.metadata?.namespace || 'default';\n  const specType = resource.spec?.type || (resource.spec?.warm ? 'warm' : 'cold');\n\n  let migrationType: MigrationType = MigrationTypes.Unknown as MigrationType;\n  if (specType === 'warm') migrationType = MigrationTypes.Warm as MigrationType;\n  else if (specType === 'cold') migrationType = MigrationTypes.Cold as MigrationType;\n\n  const conditions: Condition[] = (resource.status?.conditions || []).map(c => ({\n    type: c.type || '',\n    status: c.status || '',\n    category: c.category,\n    message: c.message || '',\n    timestamp: new Date(c.lastTransitionTime || 0),\n  }));\n\n  const archived = !!resource.spec?.archived;\n\n  let status = PlanStatuses.Pending as string;\n  for (const cond of conditions) {\n    if (cond.type === 'Succeeded' && cond.status === ConditionStatus.True) {\n      status = PlanStatuses.Succeeded;\n      break;\n    }\n    if (cond.type === 'Failed' && cond.status === ConditionStatus.True) {\n      status = PlanStatuses.Failed;\n      break;\n    }\n    if (cond.type === 'Executing' && cond.status === ConditionStatus.True) {\n      status = PlanStatuses.Running;\n    }\n    if (cond.type === 'Ready' && cond.status === ConditionStatus.True && status === PlanStatuses.Pending) {\n      status = PlanStatuses.Ready;\n    }\n  }\n\n  const vms: Record<string, VM> = {};\n  const migrationVMs = resource.status?.migration?.vms || [];\n\n  // Infer status from migration / VM data when conditions are absent or inconclusive\n  if (status === PlanStatuses.Pending || status === PlanStatuses.Ready) {\n    const migration = resource.status?.migration;\n\n    if (migrationVMs.length > 0) {\n      // A VM has an error if it has a top-level error OR any pipeline step has an error\n      const hasError = migrationVMs.some(\n        vm => !!vm.error || vm.pipeline?.some(step => !!step.error),\n      );\n      // A VM is complete if it has a completed timestamp OR its phase is \"Completed\"\n      const allCompleted = migrationVMs.every(\n        vm => !!vm.completed || vm.phase === Phases.Completed,\n      );\n\n      if (hasError) {\n        status = PlanStatuses.Failed;\n      } else if (migration?.completed || allCompleted) {\n        status = PlanStatuses.Succeeded;\n      } else if (migration?.started) {\n        status = PlanStatuses.Running;\n      }\n    }\n  }\n\n  for (const yamlVM of migrationVMs) {\n    const vm = convertVMStatus(yamlVM, migrationType);\n    if (vm) {\n      vms[vm.id] = vm;\n    }\n  }\n\n  const migStarted = resource.status?.migration?.started;\n  const migCompleted = resource.status?.migration?.completed;\n\n  // Build plan spec info\n  const spec: PlanSpec | undefined = resource.spec ? {\n    description: resource.spec.description,\n    targetNamespace: resource.spec.targetNamespace,\n    preserveStaticIPs: resource.spec.preserveStaticIPs,\n    skipGuestConversion: resource.spec.skipGuestConversion,\n    useCompatibilityMode: resource.spec.useCompatibilityMode,\n    runPreflightInspection: resource.spec.runPreflightInspection,\n    targetPowerState: resource.spec.targetPowerState,\n    migrateSharedDisks: resource.spec.migrateSharedDisks,\n    pvcNameTemplateUseGenerateName: resource.spec.pvcNameTemplateUseGenerateName,\n    preserveClusterCPUModel: resource.spec.preserveClusterCpuModel,\n    deleteGuestConversionPod: resource.spec.deleteGuestConversionPod,\n    deleteVmOnFailMigration: resource.spec.deleteVmOnFailMigration,\n    installLegacyDrivers: resource.spec.installLegacyDrivers,\n    transferNetwork: resource.spec.transferNetwork?.name,\n    sourceProvider: resource.spec.provider?.source?.name,\n    destinationProvider: resource.spec.provider?.destination?.name,\n    networkMap: resource.spec.map?.network?.name,\n    storageMap: resource.spec.map?.storage?.name,\n  } : undefined;\n\n  return {\n    name,\n    namespace,\n    status: status as Plan['status'],\n    archived,\n    migrationType,\n    conditions,\n    vms,\n    errors: [],\n    panics: [],\n    firstSeen: new Date(migStarted || resource.metadata?.creationTimestamp || 0),\n    lastSeen: new Date(migCompleted || migStarted || resource.metadata?.creationTimestamp || 0),\n    spec,\n  };\n}\n\n/**\n * Convert a YAML VM status to our internal VM type\n */\nfunction convertVMStatus(yamlVM: YamlVMStatus, planMigrationType: MigrationType): VM | null {\n  const id = yamlVM.id || '';\n  const name = yamlVM.name || '';\n  if (!id && !name) return null;\n\n  const vmId = id || name;\n  const isWarm = planMigrationType === MigrationTypes.Warm;\n  const precopies = (isWarm && yamlVM.warm?.precopies) ? yamlVM.warm.precopies : [];\n  const precopyCount = precopies.length;\n\n  const phaseHistory: PhaseInfo[] = [];\n  const phaseLogs: Record<string, RawLogEntry[]> = {};\n  const phaseLogSummaries: Record<string, PhaseLogSummary> = {};\n\n  const stepNameMap: Record<string, string> = {\n    'Initialize': PipelineSteps.Initialize,\n    'PreflightInspection': PipelineSteps.PreflightInspection,\n    'DiskAllocation': PipelineSteps.DiskAllocation,\n    'DiskTransfer': PipelineSteps.DiskTransfer,\n    'DiskTransferV2v': PipelineSteps.DiskTransferV2v,\n    'Cutover': PipelineSteps.Cutover,\n    'ImageConversion': PipelineSteps.ImageConversion,\n    'VirtualMachineCreation': PipelineSteps.VMCreation,\n  };\n\n  for (const step of yamlVM.pipeline || []) {\n    const stepName = stepNameMap[step.name || ''] || step.name || '';\n    const phaseName = step.name || 'Unknown';\n    const isDiskTransfer = phaseName === 'DiskTransfer';\n    const stepPhase = step.phase || '';\n    const isPending = stepPhase === 'Pending' || (!step.started && !step.completed && !step.error);\n\n    // Only add to phaseHistory if the step actually ran (not Pending)\n    const started = step.started ? new Date(step.started) : undefined;\n    const completed = step.completed ? new Date(step.completed) : undefined;\n    const durationMs = started && completed ? completed.getTime() - started.getTime() : undefined;\n\n    if (!isPending) {\n      phaseHistory.push({\n        name: phaseName,\n        step: stepName,\n        startedAt: started || new Date(0),\n        endedAt: completed,\n      });\n    }\n\n    // Build logs for this step (skip pending steps with no useful info)\n    if (isPending) continue;\n\n    const logs: RawLogEntry[] = [];\n    const logTimestamp = started || new Date(0);\n\n    // Step info log\n    logs.push({\n      timestamp: logTimestamp.toISOString(),\n      level: 'info',\n      message: `${step.description || phaseName} - Phase: ${stepPhase || 'Unknown'}`,\n      phase: phaseName,\n      rawLine: JSON.stringify({\n        step: phaseName,\n        description: step.description,\n        phase: stepPhase,\n        progress: step.progress,\n        started: step.started,\n        completed: step.completed,\n      }, null, 2),\n    });\n\n    // Progress info\n    if (step.progress) {\n      const unit = step.annotations?.unit || '';\n      const progressStr = unit\n        ? `${step.progress.completed || 0}/${step.progress.total || 0} ${unit}`\n        : `${step.progress.completed || 0}/${step.progress.total || 0}`;\n      logs.push({\n        timestamp: (completed || logTimestamp).toISOString(),\n        level: 'info',\n        message: `Progress: ${progressStr}`,\n        phase: phaseName,\n        rawLine: JSON.stringify({ progress: step.progress, annotations: step.annotations }, null, 2),\n      });\n    }\n\n    // Task info\n    for (const task of step.tasks || []) {\n      logs.push({\n        timestamp: (task.started ? new Date(task.started) : logTimestamp).toISOString(),\n        level: 'info',\n        message: `Task: ${task.name || 'unknown'}${task.reason ? ` - ${task.reason}` : ''}${task.annotations?.Precopy ? ` (Precopy #${task.annotations.Precopy})` : ''}`,\n        phase: phaseName,\n        rawLine: JSON.stringify(task, null, 2),\n      });\n    }\n\n    // Step error\n    if (step.error) {\n      for (const reason of step.error.reasons || []) {\n        logs.push({\n          timestamp: (completed || logTimestamp).toISOString(),\n          level: 'error',\n          message: `${phaseName} failed: ${reason}`,\n          phase: phaseName,\n          rawLine: JSON.stringify({\n            step: phaseName,\n            error: step.error,\n          }, null, 2),\n        });\n      }\n    }\n\n    // For DiskTransfer in warm migrations, add precopy details\n    if (isDiskTransfer && precopyCount > 0) {\n      addPrecopyLogs(logs, precopies, yamlVM.warm!, phaseName);\n    }\n\n    phaseLogs[phaseName] = logs;\n\n    phaseLogSummaries[phaseName] = {\n      phase: phaseName,\n      startTime: started?.toISOString(),\n      endTime: completed?.toISOString(),\n      duration: durationMs ? formatDuration(durationMs) : undefined,\n      durationMs,\n      totalLogs: logs.length,\n      groupedLogs: groupLogs(logs),\n      // Add precopy summary items for DiskTransfer\n      summaryItems: isDiskTransfer && precopyCount > 0 ? [\n        { label: 'Precopies', value: `${precopyCount}`, type: 'info' },\n        { label: 'Successes', value: `${yamlVM.warm?.successes || 0}`, type: 'info' },\n        ...(yamlVM.warm?.failures ? [{ label: 'Failures', value: `${yamlVM.warm.failures}`, type: 'error' }] : []),\n      ] : undefined,\n    };\n  }\n\n  // Extract VM-level error\n  let vmError: VMError | undefined;\n  if (yamlVM.error) {\n    vmError = {\n      phase: yamlVM.error.phase || '',\n      reasons: yamlVM.error.reasons || [],\n    };\n  }\n\n  // Extract VM-level conditions\n  const vmConditions: Condition[] = (yamlVM.conditions || []).map(c => ({\n    type: c.type || '',\n    status: c.status || '',\n    category: c.category,\n    message: c.message || '',\n    timestamp: new Date(c.lastTransitionTime || 0),\n  }));\n\n  const currentPhase = yamlVM.phase || (phaseHistory.length > 0 ? phaseHistory[phaseHistory.length - 1].name : '');\n  const currentStep = currentPhase ? phaseToStep(currentPhase, isWarm) : '';\n\n  const vmStarted = yamlVM.started ? new Date(yamlVM.started) : new Date(0);\n  const vmCompleted = yamlVM.completed ? new Date(yamlVM.completed) : undefined;\n\n  // Build structured warm info\n  let warmInfo: WarmInfo | undefined;\n  if (isWarm && precopyCount > 0) {\n    const precopyInfos: PrecopyInfo[] = precopies.map((p, i) => {\n      const start = p.start ? new Date(p.start) : undefined;\n      const end = p.end ? new Date(p.end) : undefined;\n      const durationMs = start && end ? end.getTime() - start.getTime() : undefined;\n      return {\n        iteration: i + 1,\n        snapshot: p.snapshot || 'unknown',\n        startedAt: start,\n        endedAt: end,\n        durationMs,\n        disks: (p.deltas || []).map(d => d.disk || '').filter(Boolean),\n      };\n    });\n    warmInfo = {\n      precopies: precopyInfos,\n      successes: yamlVM.warm?.successes || 0,\n      failures: yamlVM.warm?.failures || 0,\n      consecutiveFailures: yamlVM.warm?.consecutiveFailures || 0,\n      nextPrecopyAt: yamlVM.warm?.nextPrecopyAt,\n    };\n  }\n\n  return {\n    id: vmId,\n    name,\n    currentPhase,\n    currentStep,\n    migrationType: planMigrationType,\n    transferMethod: 'Unknown',\n    phaseHistory,\n    dataVolumes: [],\n    createdResources: [],\n    phaseLogs,\n    phaseLogSummaries,\n    firstSeen: vmStarted,\n    lastSeen: vmCompleted || vmStarted,\n    fromYaml: true,\n    precopyCount: precopyCount > 0 ? precopyCount : undefined,\n    warmInfo,\n    error: vmError,\n    conditions: vmConditions.length > 0 ? vmConditions : undefined,\n    operatingSystem: yamlVM.operatingSystem,\n    restorePowerState: yamlVM.restorePowerState,\n    newName: yamlVM.newName && yamlVM.newName !== name ? yamlVM.newName : undefined,\n  };\n}\n\n/**\n * Add precopy iteration logs to DiskTransfer\n */\nfunction addPrecopyLogs(\n  logs: RawLogEntry[],\n  precopies: YamlPrecopy[],\n  warm: NonNullable<YamlVMStatus['warm']>,\n  phaseName: string,\n): void {\n  for (let i = 0; i < precopies.length; i++) {\n    const precopy = precopies[i];\n    const iteration = i + 1;\n    const start = precopy.start ? new Date(precopy.start) : undefined;\n    const end = precopy.end ? new Date(precopy.end) : undefined;\n    const durationMs = start && end ? end.getTime() - start.getTime() : undefined;\n\n    const disks = (precopy.deltas || []).map(d => d.disk).filter(Boolean).join(', ');\n\n    logs.push({\n      timestamp: (start || new Date(0)).toISOString(),\n      level: 'info',\n      message: `Precopy ${iteration}/${precopies.length}: ${precopy.snapshot || 'snapshot'}${durationMs ? ` (${formatDuration(durationMs)})` : ''}${disks ? ` - ${disks}` : ''}`,\n      phase: phaseName,\n      rawLine: JSON.stringify({\n        precopyIteration: iteration,\n        totalPrecopies: precopies.length,\n        snapshot: precopy.snapshot,\n        start: precopy.start,\n        end: precopy.end,\n        duration: durationMs ? formatDuration(durationMs) : undefined,\n        createTaskId: precopy.createTaskId,\n        removeTaskId: precopy.removeTaskId,\n        deltas: precopy.deltas,\n      }, null, 2),\n    });\n  }\n\n  // Precopy summary\n  logs.push({\n    timestamp: new Date().toISOString(),\n    level: warm.failures ? 'warning' : 'info',\n    message: `Precopy summary: ${warm.successes || 0} successes, ${warm.failures || 0} failures`,\n    phase: phaseName,\n    rawLine: JSON.stringify({\n      successes: warm.successes,\n      failures: warm.failures,\n      consecutiveFailures: warm.consecutiveFailures,\n      nextPrecopyAt: warm.nextPrecopyAt,\n    }, null, 2),\n  });\n}\n","/**\n * Shared helpers for virt-v2v log parsing.\n * Line categorization, command parsing, version detection, and regex patterns.\n */\n\nimport type {\n  V2VLineCategory,\n  V2VError,\n  V2VExitStatus,\n  V2VPipelineStage,\n  V2VApiCall,\n  V2VGuestCommand,\n  V2VHostCommand,\n  V2VComponentVersions,\n} from '../../types/v2v';\n\n//  Line matching regexes \n\n/** virt-v2v pipeline stage: `[   0.0] Setting up the source` (1 decimal) */\nexport const STAGE_RE = /^\\[\\s*(\\d+\\.\\d)\\]\\s+(.+)$/;\n\n/** Kernel boot line: `[    0.000000]` (3+ decimals) */\nexport const KERNEL_BOOT_RE = /^\\[\\s*\\d+\\.\\d{3,}\\]/;\n\n/** libguestfs trace api call  captures: [1]=handle (v2v, virtio_win, ...), [2]=api name, [3]=args */\nexport const LIBGUESTFS_TRACE_RE = /^libguestfs: trace: (\\w+): (\\S+)\\s*(.*)/;\n\n/** libguestfs add_drive */\nexport const LIBGUESTFS_DRIVE_RE =\n  /add_drive\\s+\"([^\"]*)\"\\s+\"format:([^\"]*)\"\\s+\"protocol:([^\"]*)\"\\s+\"server:([^\"]*)\"/;\n\n/** libguestfs set_memsize */\nexport const LIBGUESTFS_MEMSIZE_RE = /set_memsize\\s+(\\d+)/;\n\n/** libguestfs set_smp */\nexport const LIBGUESTFS_SMP_RE = /set_smp\\s+(\\d+)/;\n\n/** libguestfs backend */\nexport const LIBGUESTFS_BACKEND_RE = /^libguestfs: launch: backend=(.+)/;\n\n/** libguestfs identifier from kernel command line */\nexport const LIBGUESTFS_ID_RE = /guestfs_identifier=(\\S+)/;\n\n/** command execution: `command: blkid '-c' ...` */\nexport const COMMAND_RE = /^command:\\s+(\\S+)\\s*(.*)/;\n\n/** command return code: `command: blkid returned 0` */\nexport const CMD_RETURN_RE = /^command:\\s+(\\S+)\\s+returned\\s+(\\d+)/;\n\n/** command stdout header: `command: blkid: stdout:` */\nexport const CMD_STDOUT_RE = /^command:\\s+(\\S+):\\s+stdout:$/;\n\n/** commandrvf metadata: `commandrvf: stdout=y stderr=y flags=0x0` */\nexport const COMMANDRVF_META_RE = /^commandrvf:\\s+stdout=[yn]\\s+stderr=[yn]\\s+flags=/;\n\n/** commandrvf execution: `commandrvf: udevadm --debug settle` */\nexport const COMMANDRVF_EXEC_RE = /^commandrvf:\\s+(\\S+)\\s*(.*)/;\n\n/** chroot execution */\nexport const CHROOT_RE = /^chroot:\\s+(\\S+):\\s+running\\s+'([^']+)'/;\n\n/** libguestfs command: run: */\nexport const LIBGUESTFS_CMD_RE = /^libguestfs: command: run:\\s*(.*)/;\n\n/** virt-v2v monitoring progress */\nexport const MONITOR_PROGRESS_RE = /virt-v2v monitoring:\\s*Progress update, completed\\s+(\\d+)\\s*%/;\n\n/** virt-v2v monitoring disk copy */\nexport const MONITOR_DISK_RE = /virt-v2v monitoring:\\s*Copying disk\\s+(\\d+)\\s+out of\\s+(\\d+)/;\n\n/** guestfsd request start: `guestfsd: <= list_partitions (0x8) request length 40 bytes` */\nexport const GUESTFSD_START_RE = /^guestfsd:\\s+<=\\s+(\\w+)\\s+\\(0x[\\da-f]+\\)/i;\n\n/** guestfsd request end: `guestfsd: => list_partitions (0x8) took 0.04 secs` */\nexport const GUESTFSD_END_RE = /^guestfsd:\\s+=>\\s+(\\w+)\\s+\\(0x[\\da-f]+\\)\\s+took\\s+([\\d.]+)\\s+secs/i;\n\n/** error patterns (context-aware) */\nexport const ERROR_RE = /\\berror[:\\s]/i;\nexport const WARNING_RE = /\\bwarning[:\\s]/i;\n\n/** check_host_free_space: large_tmpdir=/var/tmp free_space=56748552192 */\nexport const HOST_FREE_SPACE_RE = /^check_host_free_space:\\s+large_tmpdir=(\\S+)\\s+free_space=(\\d+)/;\n\n//  Version detection regexes \n\n/** info: virt-v2v: virt-v2v 2.7.1rhel=9,release=8.el9_6 (x86_64) */\nexport const VERSION_VIRTV2V_RE = /^info:\\s*(?:virt-v2v[\\w-]*):\\s*virt-v2v\\s+([\\d.]+\\S*)/;\n/** info: libvirt version: 10.10.0 */\nexport const VERSION_LIBVIRT_RE = /^info:\\s*libvirt version:\\s*([\\d.]+)/;\n/** nbdkit 1.38.5 (nbdkit-...) */\nexport const VERSION_NBDKIT_RE = /\\bnbdkit\\s+([\\d]+\\.[\\d]+\\.[\\d]+)/;\n/** VMware VixDiskLib (7.0.3) Release ... */\nexport const VERSION_VDDK_RE = /VMware VixDiskLib \\(([\\d.]+)\\)/;\n/** libguestfs: qemu version: 9.1  or  qemu version (reported by libvirt) = 10000000 */\nexport const VERSION_QEMU_RE = /libguestfs:\\s*qemu version[^:]*:\\s*([\\d.]+)/;\n/** libguestfs: trace: v2v: version = <struct guestfs_version = major: 1, minor: 56, release: 1 */\nexport const VERSION_LIBGUESTFS_RE =\n  /libguestfs: trace: \\w+: version = <struct guestfs_version = major: (\\d+), minor: (\\d+), release: (\\d+)/;\n/** virtio-win version from ISO path: virtio-win-1.9.46.iso */\nexport const VERSION_VIRTIO_WIN_RE = /virtio-win-([\\d.]+)\\.iso/;\n\n//  Line categorization / noise filtering \n\n/** false-positive error patterns to ignore */\nexport const ERROR_FALSE_POSITIVES = [\n  /get_backend_setting = NULL \\(error\\)/,\n  /usbserial.*error/i,\n  /error: No error/,\n  /TLS disabled/,\n];\n\n/** Known line prefixes that indicate stdout capture should stop. */\nexport const KNOWN_PREFIXES = [\n  'command:',\n  'commandrvf:',\n  'chroot:',\n  'guestfsd:',\n  'libguestfs:',\n  'nbdkit:',\n  'supermin:',\n  'libnbd:',\n  'info:',\n  'virt-v2v',\n  'umount-all:',\n  'Building command',\n  'windows:',\n  'hivex:',\n  // Noisy udev / systemd / varlink / debug prefixes (stop stdout capture)\n  'udev:',\n  'udevadm:',\n  'varlink:',\n  'list_filesystems:',\n];\n\n/** Commands to omit entirely (noisy, run before every disk operation). */\nexport const NOISY_COMMANDS = ['udevadm'];\n\n/** Noisy stderr / interstitial lines that should stop stdout capture. */\nexport const NOISY_LINE_RE =\n  /^(?:No filesystem is currently mounted on|Failed to determine unit we run in|SELinux enabled state cached to|varlink:|udev:|udevadm:)/;\n\n/** Corrupted prefixes from interleaved concurrent process output. */\nexport const CORRUPTED_PREFIX_RE =\n  /^(?:gulibguestfs:|estfsd:|uestfsd:|stfsd:|glibguestfs:|guelibguestfs:|gueslibguestfs:|guestfsdlibguestfs:|tfsd:)/;\n\n/** Data-driven version detection: try each regex against the line. */\nexport const VERSION_MATCHERS: { key: keyof V2VComponentVersions; re: RegExp; fmt?: (m: RegExpMatchArray) => string }[] = [\n  { key: 'virtV2v', re: VERSION_VIRTV2V_RE },\n  { key: 'libvirt', re: VERSION_LIBVIRT_RE },\n  { key: 'nbdkit', re: VERSION_NBDKIT_RE },\n  { key: 'vddk', re: VERSION_VDDK_RE },\n  { key: 'qemu', re: VERSION_QEMU_RE },\n  { key: 'libguestfs', re: VERSION_LIBGUESTFS_RE, fmt: (m) => `${m[1]}.${m[2]}.${m[3]}` },\n  { key: 'virtioWin', re: VERSION_VIRTIO_WIN_RE },\n];\n\n//  Helper functions \n\nexport function categorizeLine(line: string): V2VLineCategory {\n  if (KERNEL_BOOT_RE.test(line)) return 'kernel';\n  if (STAGE_RE.test(line)) return 'stage';\n  if (line.startsWith('nbdkit:') || line.startsWith('running nbdkit')) return 'nbdkit';\n  if (line.startsWith('libguestfs:')) return 'libguestfs';\n  if (line.startsWith('guestfsd:')) return 'guestfsd';\n  if (line.startsWith('command:') || line.startsWith('commandrvf:') || line.startsWith('chroot:'))\n    return 'command';\n  if (line.startsWith('info:')) return 'info';\n  if (/virt-v2v monitoring:/i.test(line)) return 'monitor';\n  if (line.trimStart().startsWith('<')) return 'xml';\n  if (/^\\s*(apiVersion:|kind:|metadata:|spec:|status:|---\\s*$)/.test(line)) return 'yaml';\n  if (WARNING_RE.test(line)) return 'warning';\n  if (ERROR_RE.test(line) && !isErrorFalsePositive(line)) return 'error';\n  return 'other';\n}\n\nexport function isKnownPrefix(line: string): boolean {\n  for (const prefix of KNOWN_PREFIXES) {\n    if (line.startsWith(prefix)) return true;\n  }\n  // Pipeline stages\n  if (STAGE_RE.test(line) && !KERNEL_BOOT_RE.test(line)) return true;\n  // Kernel boot lines\n  if (KERNEL_BOOT_RE.test(line)) return true;\n  // Common noisy stderr / interstitial lines\n  if (NOISY_LINE_RE.test(line)) return true;\n  // Corrupted / interleaved prefixes from concurrent process output\n  if (CORRUPTED_PREFIX_RE.test(line)) return true;\n  // Guest inspection info lines (i_root, i_type, etc.)\n  if (/^i_\\w+\\s*=/.test(line)) return true;\n  // Inspection structured block lines\n  if (/^inspect_/.test(line)) return true;\n  if (/^fs:\\s+\\/dev\\//.test(line)) return true;\n  if (/^check_filesystem:/.test(line)) return true;\n  if (/^check_for_filesystem/.test(line)) return true;\n  if (/^get_windows_systemroot/.test(line)) return true;\n  // Root device header from inspect_get_roots: `/dev/sda1 (xfs):`\n  if (/^\\/dev\\/\\S+\\s+\\(\\w+\\):/.test(line)) return true;\n  // Indented fields from inspect_os / inspect_get_roots structured blocks\n  // e.g. \"    type: linux\", \"    distro: amazonlinux\", \"    fstab: [...]\"\n  if (/^\\s{4}\\w[\\w\\s]*\\w\\s*:/.test(line)) return true;\n  return false;\n}\n\nexport function isNoisyCommand(name: string): boolean {\n  return NOISY_COMMANDS.includes(name);\n}\n\nexport function parseCommandArgs(argsStr: string): string[] {\n  if (!argsStr) return [];\n  // Split on spaces but respect quoted strings\n  const args: string[] = [];\n  const re = /'([^']*)'|\"([^\"]*)\"|(\\S+)/g;\n  let m;\n  while ((m = re.exec(argsStr)) !== null) {\n    args.push(m[1] ?? m[2] ?? m[3]);\n  }\n  return args;\n}\n\nexport function isErrorFalsePositive(line: string): boolean {\n  for (const fp of ERROR_FALSE_POSITIVES) {\n    if (fp.test(line)) return true;\n  }\n  // nbdkit debug lines that mention \"error\" in VDDK timestamps\n  if (line.startsWith('nbdkit:') && line.includes('debug:')) return true;\n  return false;\n}\n\nexport function extractSource(line: string): string {\n  if (line.startsWith('nbdkit:')) return 'nbdkit';\n  if (line.startsWith('libguestfs:')) return 'libguestfs';\n  if (line.startsWith('guestfsd:')) return 'guestfsd';\n  if (line.startsWith('supermin:')) return 'supermin';\n  if (line.startsWith('libnbd:')) return 'libnbd';\n  if (/^virt-v2v-in-place:/.test(line)) return 'virt-v2v-in-place';\n  if (/^virt-v2v-inspector:/.test(line)) return 'virt-v2v-inspector';\n  if (/^virt-v2v-customize:|^virt-customize:/.test(line)) return 'virt-v2v-customize';\n  if (/^virt-v2v:/.test(line)) return 'virt-v2v';\n  return 'unknown';\n}\n\n/**\n * Infer the exit status of a tool run from available signals:\n * - \"Finishing off\" stage reached  likely success\n * - Fatal errors from virt-v2v/virt-v2v-in-place  error\n * - \"virt-v2v monitoring: Finished\" in raw lines  success\n */\nexport function inferExitStatus(\n  stages: V2VPipelineStage[],\n  errors: V2VError[],\n  rawLines: string[],\n): V2VExitStatus {\n  const hasFinishingOff = stages.some((s) => /Finishing off/i.test(s.name));\n  const hasMonitorFinished = rawLines.some((l) => /virt-v2v monitoring:\\s*Finished/i.test(l));\n\n  // Fatal errors from the tool itself (not from libguestfs/nbdkit)\n  const hasFatalError = errors.some(\n    (e) =>\n      e.level === 'error' &&\n      /^virt-v2v/.test(e.source) &&\n      !/warning/i.test(e.message) &&\n      !/ignored\\)/i.test(e.message),\n  );\n\n  if (hasFatalError && !hasFinishingOff) return 'error';\n  if (hasFinishingOff || hasMonitorFinished) return 'success';\n  if (hasFatalError) return 'error';\n\n  // No clear signal  if we have stages, the run is likely still in progress (log was captured mid-run)\n  if (stages.length > 0) return 'in_progress';\n  return 'unknown';\n}\n\nexport function buildHostCommand(parts: string[], lineNumber: number): V2VHostCommand {\n  const command = parts[0] || '';\n  const args = parts.slice(1);\n  return { command, args, lineNumber };\n}\n\n/**\n * Find the first open API call queue whose key ends with `:apiName`.\n * Keys are stored as `handle:apiName`.\n */\nexport function findQueueByApiName(\n  openApiCalls: Map<string, V2VApiCall[]>,\n  apiName: string,\n): V2VApiCall[] | undefined {\n  const suffix = `:${apiName}`;\n  for (const [key, queue] of openApiCalls) {\n    if (key.endsWith(suffix) && queue.length > 0) return queue;\n  }\n  return undefined;\n}\n\n/**\n * Attach collected guestfsd commands to the matching open API call.\n * Finds by name (FIFO) and moves commands into the API call's guestCommands array.\n */\nexport function attachGuestfsdToApiCall(\n  scope: { name: string; commands: V2VGuestCommand[] },\n  openApiCalls: Map<string, V2VApiCall[]>,\n  completedApiCalls: V2VApiCall[],\n): void {\n  if (scope.commands.length === 0) return;\n\n  // Try open API calls first (by api name across all handles)\n  const queue = findQueueByApiName(openApiCalls, scope.name);\n  if (queue && queue.length > 0) {\n    queue[0].guestCommands.push(...scope.commands);\n    return;\n  }\n\n  // Fall back to the most recent completed API call with the same name\n  for (let i = completedApiCalls.length - 1; i >= 0; i--) {\n    if (completedApiCalls[i].name === scope.name) {\n      completedApiCalls[i].guestCommands.push(...scope.commands);\n      return;\n    }\n  }\n\n  // Last resort: attach to any open API call\n  for (const q of openApiCalls.values()) {\n    if (q.length > 0) {\n      q[0].guestCommands.push(...scope.commands);\n      return;\n    }\n  }\n}\n\nexport function parseVersionFields(line: string, versions: V2VComponentVersions): void {\n  for (const { key, re, fmt } of VERSION_MATCHERS) {\n    if (!versions[key]) {\n      const m = line.match(re);\n      if (m) {\n        (versions as Record<string, string>)[key] = fmt ? fmt(m) : m[1];\n      }\n    }\n  }\n}\n","/**\n * Hivex registry parsing for virt-v2v logs.\n * Handles hivex trace output decoding and session state management.\n */\n\nimport type { V2VRegistryHiveAccess } from '../../types/v2v';\n\n/** Mutable state for tracking a hivex registry session within the parser. */\nexport interface HivexSessionState {\n  hivePath: string;\n  mode: 'read' | 'write';\n  /** The mode the hive was originally opened with */\n  openMode: 'read' | 'write';\n  keySegments: string[];\n  values: { name: string; value: string; lineNumber: number }[];\n  pendingGetValueName: string | null;\n  /** Child name from hivex_node_get_child call, awaiting the = result to confirm navigation */\n  pendingChildName: string | null;\n  /** Parent handle for the pending child (for root-detection) */\n  pendingChildParent: string | null;\n  /** Child key name that was looked up but not found (result = 0) */\n  failedChild: string | null;\n  lineNumber: number;\n  rootHandle: string;\n  hasWriteOp: boolean;\n  firstWriteLine: number;\n}\n\n/**\n * Parse a single \\xHH hex escape at position i in string s.\n * Returns the byte value and number of characters consumed, or null.\n */\nexport function parseHexEscapeAt(s: string, i: number): { byte: number; consumed: number } | null {\n  if (s[i] === '\\\\' && i + 3 < s.length && s[i + 1] === 'x') {\n    const hex = s.substring(i + 2, i + 4);\n    const val = parseInt(hex, 16);\n    if (!isNaN(val)) return { byte: val, consumed: 4 };\n  }\n  return null;\n}\n\n/** Flush a hivex session into the accesses array if it has data. */\nexport function flushHivexSession(\n  session: HivexSessionState | null,\n  accesses: V2VRegistryHiveAccess[],\n): void {\n  if (!session) return;\n  const keyPath = session.keySegments.join('\\\\');\n\n  // Skip empty sessions  no path and no values means nothing meaningful to record\n  if (!keyPath && session.values.length === 0) return;\n\n  // Determine actual mode: use hasWriteOp to distinguish read navigations\n  // within a write-mode session from actual write operations\n  const actualMode: 'read' | 'write' = session.hasWriteOp ? 'write' : 'read';\n\n  // For writes, point to the first write operation; for reads, use navigation start\n  const lineNumber = (actualMode === 'write' && session.firstWriteLine)\n    ? session.firstWriteLine\n    : session.lineNumber;\n\n  // Avoid duplicate entries: if the last entry has the same hive, key path, mode, and\n  // line number, merge values into it instead of creating a new entry\n  const last = accesses.length > 0 ? accesses[accesses.length - 1] : null;\n  if (\n    last &&\n    last.hivePath === session.hivePath &&\n    last.keyPath === keyPath &&\n    last.mode === actualMode &&\n    last.lineNumber === lineNumber\n  ) {\n    // Merge values\n    last.values.push(...session.values);\n    return;\n  }\n\n  accesses.push({\n    hivePath: session.hivePath,\n    mode: actualMode,\n    openMode: session.openMode,\n    keyPath,\n    failedChild: session.failedChild || undefined,\n    values: session.values,\n    lineNumber,\n  });\n}\n\n/**\n * Decode the raw escaped byte data from hivex_node_set_value traces into\n * a human-readable string.\n *\n * Registry types:\n *   1 = REG_SZ (UTF-16LE string)\n *   2 = REG_EXPAND_SZ (UTF-16LE string with env-var refs)\n *   4 = REG_DWORD (32-bit LE integer)\n *   7 = REG_MULTI_SZ (series of null-terminated UTF-16LE strings)\n *   3 = REG_BINARY\n */\nexport function decodeHivexData(rawData: string, regType: number): string {\n  const bytes = parseEscapedHivexBytes(rawData);\n\n  if (regType === 4 && bytes.length >= 4) {\n    // REG_DWORD  little-endian 32-bit unsigned\n    const value = (bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | ((bytes[3] << 24) >>> 0)) >>> 0;\n    return String(value);\n  }\n\n  if (regType === 1 || regType === 2 || regType === 7) {\n    // REG_SZ / REG_EXPAND_SZ / REG_MULTI_SZ  UTF-16LE\n    return decodeUtf16LE(bytes);\n  }\n\n  // REG_BINARY or other  show hex summary\n  if (bytes.length <= 16) {\n    return bytes.map(b => b.toString(16).padStart(2, '0')).join(' ');\n  }\n  return `(${bytes.length} bytes)`;\n}\n\n/** Decode UTF-16LE bytes to a JS string, stopping at null terminator. */\nexport function decodeUtf16LE(bytes: number[]): string {\n  let result = '';\n  for (let i = 0; i + 1 < bytes.length; i += 2) {\n    const code = bytes[i] | (bytes[i + 1] << 8);\n    if (code === 0) break; // null terminator\n    result += String.fromCharCode(code);\n  }\n  return result;\n}\n\n/**\n * Parse the escaped byte string from libguestfs hivex trace output.\n *\n * libguestfs trace format:\n *   `\\xHH`  byte value HH (hex)  used for non-printable bytes\n *   `\\`     literal backslash (byte 0x5C) when NOT followed by `xHH`\n *   any other char  its ASCII byte value\n *\n * IMPORTANT: libguestfs does NOT double-escape backslashes. A `\\` in the\n * output is just byte 0x5C. So `\\\\x00` in the trace means byte 0x5C\n * followed by `\\x00` (byte 0x00)  i.e. a UTF-16LE backslash character.\n */\nexport function parseEscapedHivexBytes(s: string): number[] {\n  const bytes: number[] = [];\n  let i = 0;\n  while (i < s.length) {\n    const esc = parseHexEscapeAt(s, i);\n    if (esc) {\n      bytes.push(esc.byte);\n      i += esc.consumed;\n    } else {\n      bytes.push(s.charCodeAt(i));\n      i++;\n    }\n  }\n  return bytes;\n}\n","/**\n * NBDKIT log parsing for virt-v2v logs.\n * Extracts connection info, plugin/filter registration, and disk metadata.\n */\n\nimport type { NbdkitConnection } from '../../types/v2v';\n\n/** nbdkit socket path */\nexport const NBDKIT_SOCKET_RE = /--unix['\\s]+([^\\s']+)/;\n\n/** nbdkit NBD URI */\nexport const NBDKIT_URI_RE = /NBD URI:\\s*(\\S+)/;\n\n/** nbdkit plugin registration */\nexport const NBDKIT_PLUGIN_RE = /registered plugin\\s+\\S+\\s+\\(name\\s+(\\w+)\\)/;\n\n/** nbdkit filter registration */\nexport const NBDKIT_FILTER_RE = /registered filter\\s+\\S+\\s+\\(name\\s+(\\w+)\\)/;\n\n/** nbdkit file= config */\nexport const NBDKIT_FILE_RE = /config key=file, value=(.+)/;\n\n/** nbdkit config key=server, value=10.6.46.159 */\nexport const NBDKIT_SERVER_RE = /config key=server, value=(\\S+)/;\n\n/** nbdkit config key=vm, value=moref=vm-152 */\nexport const NBDKIT_VM_RE = /config key=vm, value=moref=(\\S+)/;\n\n/** nbdkit transport mode: nbdssl */\nexport const NBDKIT_TRANSPORT_RE = /transport mode:\\s*(\\w+)/;\n\n/** nbdkit: vddk[N]: debug: cow: underlying file size: NNNN */\nexport const COW_FILE_SIZE_RE = /cow:\\s+underlying file size:\\s+(\\d+)/;\n\nexport function finalizeNbdkit(\n  nbdkit: Partial<NbdkitConnection>,\n  map: Map<string, NbdkitConnection>,\n  endLine: number,\n): void {\n  const id = nbdkit.socketPath || `nbdkit-${map.size}`;\n  if (!map.has(id)) {\n    map.set(id, {\n      id,\n      socketPath: nbdkit.socketPath || '',\n      uri: nbdkit.uri || '',\n      plugin: nbdkit.plugin || '',\n      filters: nbdkit.filters || [],\n      diskFile: nbdkit.diskFile || '',\n      startLine: nbdkit.startLine || endLine,\n      endLine,\n      logLines: nbdkit.logLines || [],\n      server: nbdkit.server,\n      vmMoref: nbdkit.vmMoref,\n      transportMode: nbdkit.transportMode,\n      backingSize: nbdkit.backingSize,\n    });\n  }\n}\n","/**\n * Guest info parsing for virt-v2v logs.\n * Extracts installed apps, drive mappings, fstab, and source VM from libvirt XML.\n */\n\nimport type {\n  V2VGuestInfo,\n  V2VDriveMapping,\n  V2VFstabEntry,\n  V2VBlkidEntry,\n  V2VInstalledApp,\n  V2VSourceVM,\n} from '../../types/v2v';\n\n/**\n * Parse the result of `inspect_list_applications2` into structured app entries.\n *\n * Format: `= <struct guestfs_application2_list(N) = [0]{...} [1]{...} ...>`\n *\n * Values can contain commas (`VMware, Inc.`), braces (`{GUID}`), and backslashes (`C:\\...`),\n * so we use `app2_` field prefixes as delimiters instead of commas.\n */\nexport function parseInstalledApps(resultStr: string, apps: V2VInstalledApp[]): void {\n  // Split entries by `} [N]{` boundaries (or start/end markers)\n  const listStart = resultStr.indexOf('[0]{');\n  if (listStart === -1) return;\n\n  const entriesStr = resultStr.slice(listStart);\n  // Split by `} [N]{`  each chunk is one app entry (with leading/trailing junk)\n  const rawEntries = entriesStr.split(/\\}\\s*\\[\\d+\\]\\{/);\n\n  for (const raw of rawEntries) {\n    // Clean: remove leading `[0]{` and trailing `}>` or `}`\n    const fields = raw.replace(/^\\[\\d+\\]\\{/, '').replace(/\\}\\s*>?\\s*$/, '');\n\n    const app: V2VInstalledApp = {\n      name: extractAppField(fields, 'app2_name'),\n      displayName: extractAppField(fields, 'app2_display_name'),\n      version: extractAppField(fields, 'app2_version'),\n      publisher: extractAppField(fields, 'app2_publisher'),\n      installPath: extractAppField(fields, 'app2_install_path'),\n      description: extractAppField(fields, 'app2_description'),\n      arch: extractAppField(fields, 'app2_arch'),\n    };\n    if (app.displayName || app.name) {\n      apps.push(app);\n    }\n  }\n}\n\n/**\n * Extract a field value from the `app2_key: value, app2_next: ...` string.\n * Uses `, app2_` as the delimiter since values themselves can contain commas.\n */\nexport function extractAppField(fields: string, key: string): string {\n  const marker = `${key}: `;\n  const idx = fields.indexOf(marker);\n  if (idx === -1) return '';\n  const start = idx + marker.length;\n  // Value runs until the next `, app2_` boundary\n  const nextField = fields.indexOf(', app2_', start);\n  if (nextField === -1) {\n    // Last field  strip trailing comma/whitespace\n    return fields.slice(start).replace(/,?\\s*$/, '').trim();\n  }\n  return fields.slice(start, nextField).trim();\n}\n\n/**\n * Extract the product version from a CPE 2.3 string.\n * Format: `cpe:2.3:part:vendor:product:version:...`\n * Returns the version component (parts[5]) or empty string if not a CPE.\n */\nexport function extractCPEVersion(productName: string): string {\n  if (!productName.startsWith('cpe:')) return '';\n  const parts = productName.split(':');\n  if (parts.length >= 6) {\n    const ver = parts[5];\n    // `*` means unspecified in CPE\n    if (ver && ver !== '*') return ver;\n  }\n  return '';\n}\n\n/**\n * Build a V2VGuestInfo from the collected `i_` key-value pairs.\n *\n * Windows drive mappings format: `i_drive_mappings = E => /dev/sdb1; D => /dev/sda1; C => /dev/sdc2`\n * Linux fstab format (from structured block): `fstab: [(/dev/rhel/root, /), (/dev/sda2, /boot), ...]`\n */\nexport function buildGuestInfo(raw: Map<string, string>): V2VGuestInfo {\n  // Parse Windows drive mappings  two possible formats:\n  // i_ format: \"E => /dev/sdb1; D => /dev/sda1; C => /dev/sdc2\"\n  // structured block format: \"[(C, /dev/sda2), (E, /dev/sdb1), (F, /dev/sdc1)]\"\n  const driveMappings: V2VDriveMapping[] = [];\n  const mappingsStr = raw.get('drive_mappings') || '';\n  if (mappingsStr) {\n    if (mappingsStr.includes('=>')) {\n      // i_ format\n      for (const part of mappingsStr.split(';')) {\n        const m = part.trim().match(/^(\\w+)\\s*=>\\s*(.+)$/);\n        if (m) {\n          driveMappings.push({ letter: m[1], device: m[2].trim() });\n        }\n      }\n    } else {\n      // structured block format: [(C, /dev/sda2), ...]\n      const entryRe = /\\((\\w+),\\s*([^)]+)\\)/g;\n      let dm;\n      while ((dm = entryRe.exec(mappingsStr)) !== null) {\n        driveMappings.push({ letter: dm[1].trim(), device: dm[2].trim() });\n      }\n    }\n    driveMappings.sort((a, b) => a.letter.localeCompare(b.letter));\n  }\n\n  // Parse Linux fstab entries: [(/dev/rhel/root, /), (/dev/sda2, /boot), ...]\n  const fstab: V2VFstabEntry[] = [];\n  const fstabStr = raw.get('fstab') || '';\n  if (fstabStr) {\n    const entryRe = /\\(([^,]+),\\s*([^)]+)\\)/g;\n    let fm;\n    while ((fm = entryRe.exec(fstabStr)) !== null) {\n      fstab.push({ device: fm[1].trim(), mountpoint: fm[2].trim() });\n    }\n  }\n\n  // Parse version: prefer i_major_version/i_minor_version, then CPE product version,\n  // then fall back to `version: X.Y`.\n  //\n  // The structured block format (from inspect_os / inspect_get_roots) sometimes\n  // reports the CPE *specification* version (e.g. `2.3`) as the OS version,\n  // which is wrong for distros like Amazon Linux 2023 whose real version is `2023`.\n  // When product_name is a CPE string, we extract the true version from the CPE.\n  let majorVersion = parseInt(raw.get('major_version') || '0', 10);\n  let minorVersion = parseInt(raw.get('minor_version') || '0', 10);\n  if (majorVersion === 0) {\n    // Try extracting version from CPE product_name first\n    const productName = raw.get('product_name') || '';\n    const cpeVersion = extractCPEVersion(productName);\n    if (cpeVersion) {\n      const vParts = cpeVersion.split('.');\n      majorVersion = parseInt(vParts[0] || '0', 10);\n      minorVersion = parseInt(vParts[1] || '0', 10);\n    }\n    // Fall back to the explicit version field\n    if (majorVersion === 0 && raw.has('version')) {\n      const vParts = (raw.get('version') || '').split('.');\n      majorVersion = parseInt(vParts[0] || '0', 10);\n      minorVersion = parseInt(vParts[1] || '0', 10);\n    }\n  }\n\n  return {\n    root: raw.get('root') || '',\n    type: raw.get('type') || '',\n    distro: raw.get('distro') || '',\n    osinfo: raw.get('osinfo') || '',\n    arch: raw.get('arch') || '',\n    majorVersion,\n    minorVersion,\n    productName: raw.get('product_name') || '',\n    productVariant: raw.get('product_variant') || '',\n    packageFormat: raw.get('package_format') || '',\n    packageManagement: raw.get('package_management') || '',\n    hostname: raw.get('hostname') || '',\n    buildId: raw.get('build_id') || '',\n    windowsSystemroot: raw.get('windows_systemroot') || '',\n    windowsSoftwareHive: raw.get('windows_software_hive') || '',\n    windowsSystemHive: raw.get('windows_system_hive') || '',\n    windowsCurrentControlSet: raw.get('windows_current_control_set') || '',\n    driveMappings,\n    fstab,\n    blkid: [],\n  };\n}\n\n/**\n * Parse a blkid output line into a V2VBlkidEntry.\n *\n * Format: `/dev/sda1: UUID=\"B2A8-041F\" TYPE=\"vfat\" PARTLABEL=\"Basic data partition\" PARTUUID=\"7c1f7103-...\"`\n */\nconst BLKID_LINE_RE = /^(\\/dev\\/\\S+):\\s+(.+)$/;\nconst BLKID_KV_RE = /(\\w+)=\"([^\"]*)\"/g;\n\nexport function parseBlkidLine(line: string): V2VBlkidEntry | null {\n  const m = line.match(BLKID_LINE_RE);\n  if (!m) return null;\n\n  const device = m[1];\n  const kvPart = m[2];\n\n  // Verify it actually has blkid-style KEY=\"value\" pairs\n  const kvMatches = [...kvPart.matchAll(BLKID_KV_RE)];\n  if (kvMatches.length === 0) return null;\n\n  const entry: V2VBlkidEntry = { device };\n  for (const kv of kvMatches) {\n    const key = kv[1].toUpperCase();\n    const val = kv[2];\n    switch (key) {\n      case 'UUID': entry.uuid = val; break;\n      case 'TYPE': entry.type = val; break;\n      case 'PARTLABEL': entry.partLabel = val; break;\n      case 'PARTUUID': entry.partUuid = val; break;\n      case 'LABEL': entry.label = val; break;\n    }\n  }\n  return entry;\n}\n\n/**\n * Parse libvirt XML captured from log lines into a V2VSourceVM structure.\n * Uses simple regex extraction  no XML parser needed for the few fields we care about.\n */\nexport function parseLibvirtXML(lines: string[]): V2VSourceVM {\n  const xml = lines.join('\\n');\n  const vm: V2VSourceVM = { disks: [], networks: [] };\n\n  // VM name\n  const nameMatch = xml.match(/<name>([^<]+)<\\/name>/);\n  if (nameMatch) vm.name = nameMatch[1];\n\n  // Memory (in KiB)\n  const memMatch = xml.match(/<memory\\s+unit='KiB'>(\\d+)<\\/memory>/);\n  if (memMatch) vm.memoryKB = parseInt(memMatch[1], 10);\n\n  // vCPUs\n  const cpuMatch = xml.match(/<vcpu[^>]*>(\\d+)<\\/vcpu>/);\n  if (cpuMatch) vm.vcpus = parseInt(cpuMatch[1], 10);\n\n  // Firmware / OS type\n  const osTypeMatch = xml.match(/<os>[\\s\\S]*?<type[^>]*>([^<]+)<\\/type>/);\n  if (osTypeMatch) vm.firmware = osTypeMatch[1];\n  if (xml.includes('<loader') || xml.includes('ovmf') || xml.includes('OVMF')) {\n    vm.firmware = 'uefi';\n  } else if (vm.firmware === 'hvm') {\n    vm.firmware = 'bios';\n  }\n\n  // Disks: <source file='...' or <source dev='...'\n  const diskRe = /<disk\\s+[^>]*>[\\s\\S]*?<\\/disk>/g;\n  let diskMatch;\n  while ((diskMatch = diskRe.exec(xml)) !== null) {\n    const block = diskMatch[0];\n    const srcFile = block.match(/<source\\s+file='([^']+)'/)?.[1]\n      || block.match(/<source\\s+dev='([^']+)'/)?.[1]\n      || block.match(/<source\\s+name='([^']+)'/)?.[1];\n    const device = block.match(/<target\\s+dev='([^']+)'/)?.[1];\n    const fmt = block.match(/<driver[^>]+type='([^']+)'/)?.[1];\n    if (srcFile) vm.disks.push({ path: srcFile, format: fmt, device });\n  }\n\n  // Networks: <interface type='...'> ... <source .../> <model type='...'/>\n  const netRe = /<interface\\s+type='([^']+)'[^>]*>[\\s\\S]*?<\\/interface>/g;\n  let netMatch;\n  while ((netMatch = netRe.exec(xml)) !== null) {\n    const block = netMatch[0];\n    const netType = netMatch[1];\n    const model = block.match(/<model\\s+type='([^']+)'/)?.[1];\n    const source = block.match(/<source\\s+(?:network|bridge|portgroup)='([^']+)'/)?.[1];\n    vm.networks.push({ type: netType, model, source });\n  }\n\n  return vm;\n}\n","/**\n * File copy parsing for virt-v2v logs.\n * Extracts read_file/write content and original size from libguestfs trace output.\n */\n\nimport { parseHexEscapeAt } from './hivexParser';\n\n/** Extract \"original size N bytes\" from a log line */\nexport const ORIGINAL_SIZE_RE = /original size (\\d+) bytes/;\n\n/** Extract \"original size N bytes\" from a log line, or null. */\nexport function extractOriginalSize(line: string): number | null {\n  const m = line.match(ORIGINAL_SIZE_RE);\n  return m ? parseInt(m[1], 10) : null;\n}\n\n/**\n * Decode libguestfs trace string escapes: \\x0d\\x0a  \\r\\n, \\xHH  char, etc.\n */\nexport function decodeWriteEscapes(s: string): string {\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    const esc = parseHexEscapeAt(s, i);\n    if (esc) {\n      result += String.fromCharCode(esc.byte);\n      i += esc.consumed;\n      continue;\n    }\n    if (s[i] === '\\\\' && i + 1 < s.length) {\n      const next = s[i + 1];\n      if (next === 'n') { result += '\\n'; i += 2; continue; }\n      if (next === 'r') { result += '\\r'; i += 2; continue; }\n      if (next === 't') { result += '\\t'; i += 2; continue; }\n      if (next === '\\\\') { result += '\\\\'; i += 2; continue; }\n      if (next === '\"') { result += '\"'; i += 2; continue; }\n    }\n    result += s[i];\n    i++;\n  }\n  return result;\n}\n\n/**\n * Extract content from a `v2v: read_file = \"content\"` result line.\n * Returns decoded text, or null if it looks like binary.\n * Pattern: read_file = \"content here\"  or  \"content\"<truncated, original size N bytes>\n */\nexport function extractReadFileContent(line: string): string | null {\n  // Find the content after `read_file = \"`\n  const marker = 'read_file = \"';\n  const startIdx = line.indexOf(marker);\n  if (startIdx < 0) return null;\n  const contentStart = startIdx + marker.length;\n\n  // Find closing quote\n  let contentEnd = line.indexOf('\"<truncated', contentStart);\n  if (contentEnd < 0) {\n    contentEnd = line.lastIndexOf('\"');\n    if (contentEnd <= contentStart) return null;\n  }\n\n  const rawContent = line.substring(contentStart, contentEnd);\n\n  // Skip binary content  if it starts with non-printable escape sequences, it's binary\n  if (/^\\\\x[0-9a-f]{2}\\\\x[0-9a-f]{2}/i.test(rawContent) && !/^\\\\x[0-9a-f]{2}\\\\x0[0ad]/i.test(rawContent)) {\n    return null;\n  }\n\n  return decodeWriteEscapes(rawContent);\n}\n\n/**\n * Extract the inline text content from a `v2v: write` log line.\n * Returns decoded text for script-like files (.bat, .ps1, .reg, .cmd, .txt, .xml),\n * or null for binary files (.exe, .msi, .sys, .dll, .cat, .pdb, etc.).\n *\n * Line format:\n *   libguestfs: trace: v2v: write \"/path/file.bat\" \"escaped content\"\n *   libguestfs: trace: v2v: write \"/path/file.bat\" \"escaped...\"<truncated, original size N bytes>\n */\nexport function extractWriteContent(line: string, destPath: string): string | null {\n  // Skip content extraction for known binary file extensions\n  const binaryExtensions = /\\.(exe|msi|dll|sys|cat|pdb|cab|iso|img|bin|dat|drv)$/i;\n  if (binaryExtensions.test(destPath)) return null;\n\n  // Find the content between the second pair of quotes\n  // The first quoted string is the destination path, the second is the content\n  // Pattern: write \"/dest\" \"content\"  or  write \"/dest\" \"content\"<truncated...>\n  const idx = line.indexOf('\" \"');\n  if (idx < 0) return null;\n\n  // Content starts after '\" \"' (3 chars), so idx + 3\n  const contentStart = idx + 3;\n  // Find the closing quote  could be at end of line or before <truncated\n  let contentEnd = line.indexOf('\"<truncated', contentStart);\n  if (contentEnd < 0) {\n    // No truncation  last quote on the line\n    contentEnd = line.lastIndexOf('\"');\n    if (contentEnd <= contentStart) return null;\n  }\n\n  const rawContent = line.substring(contentStart, contentEnd);\n  return decodeWriteEscapes(rawContent);\n}\n","/**\n * Handler functions for parseToolRunSection.\n *\n * Each handler processes a specific category of log lines and updates the shared ParseContext.\n * The main loop calls handlers in order until one claims the line.\n */\n\nimport type {\n  V2VPipelineStage,\n  V2VDiskProgress,\n  NbdkitConnection,\n  V2VApiCall,\n  V2VGuestCommand,\n  V2VHostCommand,\n  V2VError,\n  V2VLineCategory,\n  V2VComponentVersions,\n  V2VDiskSummary,\n  V2VSourceVM,\n  V2VFileCopy,\n  V2VInstalledApp,\n  V2VRegistryHiveAccess,\n  V2VGuestInfo,\n  V2VBlkidEntry,\n  LibguestfsDrive,\n  LibguestfsApiCall,\n} from '../../types/v2v';\n\nimport {\n  HivexSessionState,\n  flushHivexSession,\n  decodeHivexData,\n} from './hivexParser';\n\nimport {\n  finalizeNbdkit,\n  NBDKIT_SOCKET_RE,\n  NBDKIT_URI_RE,\n  NBDKIT_PLUGIN_RE,\n  NBDKIT_FILTER_RE,\n  NBDKIT_FILE_RE,\n  NBDKIT_SERVER_RE,\n  NBDKIT_VM_RE,\n  NBDKIT_TRANSPORT_RE,\n  COW_FILE_SIZE_RE,\n} from './nbdkitParser';\n\nimport {\n  buildGuestInfo,\n  parseInstalledApps,\n  parseLibvirtXML,\n  parseBlkidLine,\n} from './guestInfoParser';\n\nimport {\n  extractOriginalSize,\n  extractReadFileContent,\n  extractWriteContent,\n} from './fileCopyParser';\n\nimport {\n  categorizeLine,\n  isKnownPrefix,\n  isNoisyCommand,\n  parseCommandArgs,\n  isErrorFalsePositive,\n  extractSource,\n  parseVersionFields,\n  STAGE_RE,\n  KERNEL_BOOT_RE,\n  ERROR_RE,\n  WARNING_RE,\n  MONITOR_PROGRESS_RE,\n  MONITOR_DISK_RE,\n  HOST_FREE_SPACE_RE,\n  LIBGUESTFS_TRACE_RE,\n  LIBGUESTFS_DRIVE_RE,\n  LIBGUESTFS_MEMSIZE_RE,\n  LIBGUESTFS_SMP_RE,\n  LIBGUESTFS_BACKEND_RE,\n  LIBGUESTFS_ID_RE,\n  COMMAND_RE,\n  CMD_RETURN_RE,\n  CMD_STDOUT_RE,\n  COMMANDRVF_META_RE,\n  COMMANDRVF_EXEC_RE,\n  CHROOT_RE,\n  LIBGUESTFS_CMD_RE,\n  GUESTFSD_START_RE,\n  GUESTFSD_END_RE,\n  findQueueByApiName,\n  attachGuestfsdToApiCall,\n  buildHostCommand,\n} from './v2vHelpers';\n\n// \n// ParseContext  shared mutable state for all handlers\n// \n\nexport interface ParseContext {\n  // Input\n  sectionLines: string[];\n  globalLineOffset: number;\n\n  // Output accumulators\n  stages: V2VPipelineStage[];\n  diskProgress: V2VDiskProgress[];\n  nbdkitConnections: NbdkitConnection[];\n  errors: V2VError[];\n  lineCategories: V2VLineCategory[];\n\n  // API call tracking\n  completedApiCalls: V2VApiCall[];\n  openApiCalls: Map<string, V2VApiCall[]>;\n  activeGuestfsd: { name: string; commands: V2VGuestCommand[] } | null;\n  hostCommands: V2VHostCommand[];\n\n  // Libguestfs state\n  lgBackend: string;\n  lgIdentifier: string;\n  lgMemsize: number;\n  lgSmp: number;\n  lgDrives: LibguestfsDrive[];\n  lgApiCalls: LibguestfsApiCall[];\n  lgLaunchLines: string[];\n\n  // NBDKIT state\n  currentNbdkit: Partial<NbdkitConnection> | null;\n  nbdkitMap: Map<string, NbdkitConnection>;\n\n  // Multi-line command state\n  pendingLibguestfsCmd: string[];\n  pendingLibguestfsCmdLine: number;\n\n  // Stdout capture\n  stdoutCapture: { cmdName: string } | null;\n\n  // Guest info\n  guestInfo: V2VGuestInfo | null;\n  guestInfoRaw: Map<string, string>;\n  blkidEntries: V2VBlkidEntry[];\n\n  // Versions\n  versions: V2VComponentVersions;\n\n  // Disk summary\n  diskSummary: V2VDiskSummary;\n\n  // Source VM\n  sourceVM: V2VSourceVM | null;\n  xmlCapture: string[] | null;\n\n  // VirtIO Win / file copy\n  virtioWinIsoPath: string | null;\n  fileCopies: V2VFileCopy[];\n  pendingVirtioWinRead: { source: string; sizeBytes: number | null; lineNumber: number } | null;\n  pendingV2VReads: Map<string, { content: string | null; sizeBytes: number | null; lineNumber: number }>;\n  lastV2VReadFilePath: string | null;\n\n  // Installed apps & registry\n  installedApps: V2VInstalledApp[];\n  registryHiveAccesses: V2VRegistryHiveAccess[];\n  currentHivexSession: HivexSessionState | null;\n}\n\nexport function createParseContext(\n  sectionLines: string[],\n  globalLineOffset: number,\n): ParseContext {\n  return {\n    sectionLines,\n    globalLineOffset,\n    stages: [],\n    diskProgress: [],\n    nbdkitConnections: [],\n    errors: [],\n    lineCategories: [],\n    completedApiCalls: [],\n    openApiCalls: new Map(),\n    activeGuestfsd: null,\n    hostCommands: [],\n    lgBackend: '',\n    lgIdentifier: '',\n    lgMemsize: 0,\n    lgSmp: 0,\n    lgDrives: [],\n    lgApiCalls: [],\n    lgLaunchLines: [],\n    currentNbdkit: null,\n    nbdkitMap: new Map(),\n    pendingLibguestfsCmd: [],\n    pendingLibguestfsCmdLine: 0,\n    stdoutCapture: null,\n    guestInfo: null,\n    guestInfoRaw: new Map(),\n    blkidEntries: [],\n    versions: {},\n    diskSummary: { disks: [] },\n    sourceVM: null,\n    xmlCapture: null,\n    virtioWinIsoPath: null,\n    fileCopies: [],\n    pendingVirtioWinRead: null,\n    pendingV2VReads: new Map(),\n    lastV2VReadFilePath: null,\n    installedApps: [],\n    registryHiveAccesses: [],\n    currentHivexSession: null,\n  };\n}\n\n// \n// Hivex helpers (context-bound)\n// \n\n/** Regex for \"HANDLE \\\"NAME\\\"\" patterns in hivex trace args. */\nconst HIVEX_HANDLE_NAME_RE = /(\\d+)\\s+\"([^\"]+)\"/;\n/** Regex for quoted string results in hivex trace args. */\nconst HIVEX_QUOTED_STRING_RE = /^\"(.*)\"$/;\n\nfunction resetHivexTraversal(\n  ctx: ParseContext,\n  session: HivexSessionState,\n  overrides?: { hasWriteOp?: boolean; firstWriteLine?: number; lineNumber?: number },\n): void {\n  flushHivexSession(session, ctx.registryHiveAccesses);\n  session.keySegments = [];\n  session.values = [];\n  session.pendingGetValueName = null;\n  session.pendingChildName = null;\n  session.pendingChildParent = null;\n  session.failedChild = null;\n  session.hasWriteOp = overrides?.hasWriteOp ?? false;\n  session.firstWriteLine = overrides?.firstWriteLine ?? 0;\n  if (overrides?.lineNumber !== undefined) {\n    session.lineNumber = overrides.lineNumber;\n  }\n}\n\n// \n// Guest command helpers\n// \n\nfunction addGuestCommand(ctx: ParseContext, cmd: V2VGuestCommand): void {\n  if (ctx.activeGuestfsd) {\n    ctx.activeGuestfsd.commands.push(cmd);\n  } else {\n    const allOpen = [...ctx.openApiCalls.values()];\n    const lastQueue = allOpen[allOpen.length - 1];\n    if (lastQueue && lastQueue.length > 0) {\n      lastQueue[lastQueue.length - 1].guestCommands.push(cmd);\n    }\n  }\n}\n\nfunction findLastGuestCommand(ctx: ParseContext, cmdName: string): V2VGuestCommand | undefined {\n  if (ctx.activeGuestfsd) {\n    for (let j = ctx.activeGuestfsd.commands.length - 1; j >= 0; j--) {\n      if (ctx.activeGuestfsd.commands[j].command === cmdName) return ctx.activeGuestfsd.commands[j];\n    }\n  }\n  for (const queue of ctx.openApiCalls.values()) {\n    for (let q = queue.length - 1; q >= 0; q--) {\n      const cmds = queue[q].guestCommands;\n      for (let j = cmds.length - 1; j >= 0; j--) {\n        if (cmds[j].command === cmdName) return cmds[j];\n      }\n    }\n  }\n  for (let a = ctx.completedApiCalls.length - 1; a >= 0; a--) {\n    const cmds = ctx.completedApiCalls[a].guestCommands;\n    for (let j = cmds.length - 1; j >= 0; j--) {\n      if (cmds[j].command === cmdName) return cmds[j];\n    }\n  }\n  return undefined;\n}\n\n// \n// Handler: stdout capture mode\n// \n\nexport function handleStdoutCapture(ctx: ParseContext, line: string): boolean {\n  if (!ctx.stdoutCapture) return false;\n\n  if (isKnownPrefix(line)) {\n    ctx.stdoutCapture = null;\n    return false; // fall through to normal parsing\n  }\n\n  const cmd = findLastGuestCommand(ctx, ctx.stdoutCapture.cmdName);\n  if (cmd) cmd.stdoutLines.push(line);\n  return true; // line consumed\n}\n\n// \n// Handler: pipeline stages\n// \n\nexport function handlePipelineStages(ctx: ParseContext, line: string, globalLine: number): void {\n  if (!KERNEL_BOOT_RE.test(line)) {\n    const stageMatch = line.match(STAGE_RE);\n    if (stageMatch) {\n      ctx.stages.push({\n        name: stageMatch[2].trim(),\n        elapsedSeconds: parseFloat(stageMatch[1]),\n        lineNumber: globalLine,\n      });\n    }\n  }\n}\n\n// \n// Handler: monitor progress\n// \n\nexport function handleMonitorProgress(ctx: ParseContext, line: string, globalLine: number): void {\n  const progressMatch = line.match(MONITOR_PROGRESS_RE);\n  if (progressMatch) {\n    const lastDisk = ctx.diskProgress.length > 0 ? ctx.diskProgress[ctx.diskProgress.length - 1] : null;\n    if (lastDisk) {\n      ctx.diskProgress.push({\n        diskNumber: lastDisk.diskNumber,\n        totalDisks: lastDisk.totalDisks,\n        percentComplete: parseInt(progressMatch[1], 10),\n        lineNumber: globalLine,\n      });\n    }\n  }\n\n  const diskMatch = line.match(MONITOR_DISK_RE);\n  if (diskMatch) {\n    ctx.diskProgress.push({\n      diskNumber: parseInt(diskMatch[1], 10),\n      totalDisks: parseInt(diskMatch[2], 10),\n      percentComplete: 0,\n      lineNumber: globalLine,\n    });\n  }\n}\n\n// \n// Handler: versions and host free space\n// \n\nexport function handleVersionsAndDiskInfo(ctx: ParseContext, line: string): void {\n  parseVersionFields(line, ctx.versions);\n\n  if (!ctx.diskSummary.hostFreeSpace) {\n    const m = line.match(HOST_FREE_SPACE_RE);\n    if (m) {\n      ctx.diskSummary.hostTmpDir = m[1];\n      ctx.diskSummary.hostFreeSpace = parseInt(m[2], 10);\n    }\n  }\n}\n\n// \n// Handler: libvirt XML capture\n// \n\nexport function handleLibvirtXML(ctx: ParseContext, line: string): void {\n  if (ctx.xmlCapture !== null) {\n    ctx.xmlCapture.push(line);\n    if (line.trimStart().startsWith('</domain>')) {\n      ctx.sourceVM = parseLibvirtXML(ctx.xmlCapture);\n      ctx.xmlCapture = null;\n    }\n  } else if (!ctx.sourceVM && /<domain type=/.test(line)) {\n    ctx.xmlCapture = [line];\n  }\n}\n\n// \n// Handler: NBDKIT\n// \n\nexport function handleNbdkit(ctx: ParseContext, line: string, globalLine: number): void {\n  const isNbdkitStart =\n    line.startsWith('running nbdkit:') || line.startsWith('running nbdkit ');\n  if (isNbdkitStart) {\n    ctx.currentNbdkit = { startLine: globalLine, logLines: [], filters: [] };\n  }\n\n  if (isNbdkitStart || line.startsWith('nbdkit:') || (ctx.currentNbdkit && line.startsWith(' '))) {\n    if (ctx.currentNbdkit) {\n      ctx.currentNbdkit.logLines = ctx.currentNbdkit.logLines || [];\n      ctx.currentNbdkit.logLines.push(line);\n      ctx.currentNbdkit.endLine = globalLine;\n    }\n\n    const socketMatch = line.match(NBDKIT_SOCKET_RE);\n    if (socketMatch && ctx.currentNbdkit) ctx.currentNbdkit.socketPath = socketMatch[1];\n\n    const uriMatch = line.match(NBDKIT_URI_RE);\n    if (uriMatch && ctx.currentNbdkit) {\n      ctx.currentNbdkit.uri = uriMatch[1];\n      const id = ctx.currentNbdkit.socketPath || `nbdkit-${ctx.nbdkitMap.size}`;\n      if (!ctx.nbdkitMap.has(id)) {\n        ctx.nbdkitMap.set(id, {\n          id,\n          socketPath: ctx.currentNbdkit.socketPath || '',\n          uri: ctx.currentNbdkit.uri || '',\n          plugin: ctx.currentNbdkit.plugin || '',\n          filters: ctx.currentNbdkit.filters || [],\n          diskFile: ctx.currentNbdkit.diskFile || '',\n          startLine: ctx.currentNbdkit.startLine || globalLine,\n          endLine: globalLine,\n          logLines: ctx.currentNbdkit.logLines || [],\n          server: ctx.currentNbdkit.server,\n          vmMoref: ctx.currentNbdkit.vmMoref,\n          transportMode: ctx.currentNbdkit.transportMode,\n          backingSize: ctx.currentNbdkit.backingSize,\n        });\n      }\n    }\n\n    const pluginMatch = line.match(NBDKIT_PLUGIN_RE);\n    if (pluginMatch && ctx.currentNbdkit) ctx.currentNbdkit.plugin = pluginMatch[1];\n\n    const filterMatch = line.match(NBDKIT_FILTER_RE);\n    if (filterMatch && ctx.currentNbdkit) {\n      ctx.currentNbdkit.filters = ctx.currentNbdkit.filters || [];\n      if (!ctx.currentNbdkit.filters.includes(filterMatch[1])) {\n        ctx.currentNbdkit.filters.push(filterMatch[1]);\n      }\n    }\n\n    const fileMatch = line.match(NBDKIT_FILE_RE);\n    if (fileMatch && ctx.currentNbdkit) ctx.currentNbdkit.diskFile = fileMatch[1];\n\n    const serverMatch = line.match(NBDKIT_SERVER_RE);\n    if (serverMatch && ctx.currentNbdkit) ctx.currentNbdkit.server = serverMatch[1];\n\n    const vmMatch = line.match(NBDKIT_VM_RE);\n    if (vmMatch && ctx.currentNbdkit) ctx.currentNbdkit.vmMoref = vmMatch[1];\n\n    const transportMatch = line.match(NBDKIT_TRANSPORT_RE);\n    if (transportMatch && ctx.currentNbdkit) ctx.currentNbdkit.transportMode = transportMatch[1];\n\n    const cowMatch = line.match(COW_FILE_SIZE_RE);\n    if (cowMatch && ctx.currentNbdkit) ctx.currentNbdkit.backingSize = parseInt(cowMatch[1], 10);\n  } else if (ctx.currentNbdkit && !line.startsWith('nbdkit:')) {\n    finalizeNbdkit(ctx.currentNbdkit, ctx.nbdkitMap, globalLine);\n    ctx.currentNbdkit = null;\n  }\n\n  // Standalone nbdkit log lines\n  if (line.startsWith('nbdkit:') && !ctx.currentNbdkit) {\n    const lastConn = [...ctx.nbdkitMap.values()].pop();\n    if (lastConn) {\n      lastConn.logLines.push(line);\n      lastConn.endLine = globalLine;\n    }\n  }\n}\n\n// \n// Handler: libguestfs trace & config (including hivex, API calls)\n// \n\nexport function handleLibguestfsTrace(ctx: ParseContext, line: string, globalLine: number): void {\n  if (!line.startsWith('libguestfs:')) return;\n\n  const backendMatch = line.match(LIBGUESTFS_BACKEND_RE);\n  if (backendMatch) {\n    ctx.lgBackend = backendMatch[1];\n    ctx.lgLaunchLines.push(line);\n  }\n\n  const idMatch = line.match(LIBGUESTFS_ID_RE);\n  if (idMatch) ctx.lgIdentifier = idMatch[1];\n\n  if (line.includes('libguestfs: launch:')) ctx.lgLaunchLines.push(line);\n\n  const traceMatch = line.match(LIBGUESTFS_TRACE_RE);\n  if (traceMatch) {\n    const traceHandle = traceMatch[1];\n    const apiName = traceMatch[2];\n    const apiArgs = traceMatch[3];\n\n    const memMatch = apiArgs.match(LIBGUESTFS_MEMSIZE_RE);\n    if (memMatch) ctx.lgMemsize = parseInt(memMatch[1], 10);\n\n    const smpMatch = apiArgs.match(LIBGUESTFS_SMP_RE);\n    if (smpMatch) ctx.lgSmp = parseInt(smpMatch[1], 10);\n\n    const driveMatch = line.match(LIBGUESTFS_DRIVE_RE);\n    if (driveMatch) {\n      ctx.lgDrives.push({\n        path: driveMatch[1],\n        format: driveMatch[2],\n        protocol: driveMatch[3],\n        server: driveMatch[4],\n      });\n    }\n\n    // Installed apps\n    if (apiName === 'inspect_list_applications2' && apiArgs.startsWith('=')) {\n      parseInstalledApps(apiArgs, ctx.installedApps);\n    }\n\n    // Hivex session tracking\n    handleHivexTrace(ctx, apiName, apiArgs, globalLine);\n\n    // Flat API call list for LibguestfsInfo panel\n    if (!apiName.endsWith('=') && apiName !== '=') {\n      ctx.lgApiCalls.push({ name: apiName, args: apiArgs, result: '', lineNumber: globalLine });\n    } else if (apiName === '=' || apiArgs.startsWith('=')) {\n      const lastCall = ctx.lgApiCalls[ctx.lgApiCalls.length - 1];\n      if (lastCall) {\n        lastCall.result = apiArgs.replace(/^=\\s*/, '').trim() || apiName;\n      }\n    }\n\n    // Hierarchical API call tracking\n    const isResult = apiName === '=' || apiArgs.startsWith('=');\n    if (!isResult && !apiName.endsWith('=')) {\n      const apiCall: V2VApiCall = {\n        name: apiName,\n        args: apiArgs,\n        result: '',\n        handle: traceHandle,\n        guestCommands: [],\n        lineNumber: globalLine,\n      };\n      const queueKey = `${traceHandle}:${apiName}`;\n      const queue = ctx.openApiCalls.get(queueKey) || [];\n      queue.push(apiCall);\n      ctx.openApiCalls.set(queueKey, queue);\n    } else {\n      let resultName = '';\n      let resultValue = '';\n      if (apiName === '=') {\n        const lastLgCall = ctx.lgApiCalls[ctx.lgApiCalls.length - 1];\n        if (lastLgCall) resultName = lastLgCall.name;\n        resultValue = apiArgs.replace(/^=?\\s*/, '').trim();\n      } else if (apiArgs.startsWith('=')) {\n        resultName = apiName.replace(/=$/, '');\n        resultValue = apiArgs.replace(/^=\\s*/, '').trim();\n      }\n\n      if (resultName) {\n        const resultKey = `${traceHandle}:${resultName}`;\n        const queue = ctx.openApiCalls.get(resultKey);\n        if (queue && queue.length > 0) {\n          const apiCall = queue.shift()!;\n          apiCall.result = resultValue;\n          ctx.completedApiCalls.push(apiCall);\n          if (queue.length === 0) ctx.openApiCalls.delete(resultKey);\n        }\n      }\n    }\n  }\n\n  // libguestfs command: run: (multi-line host command)\n  const cmdMatch = line.match(LIBGUESTFS_CMD_RE);\n  if (cmdMatch) {\n    const cmdText = cmdMatch[1].trim();\n    if (cmdText && !cmdText.startsWith('\\\\')) {\n      if (ctx.pendingLibguestfsCmd.length > 0) {\n        ctx.hostCommands.push(buildHostCommand(ctx.pendingLibguestfsCmd, ctx.pendingLibguestfsCmdLine));\n      }\n      ctx.pendingLibguestfsCmd = [cmdText];\n      ctx.pendingLibguestfsCmdLine = globalLine;\n    } else if (cmdText.startsWith('\\\\')) {\n      ctx.pendingLibguestfsCmd.push(cmdText.slice(1).trim());\n    }\n  }\n}\n\n// \n// Handler: hivex trace lines (called from handleLibguestfsTrace)\n// \n\nfunction handleHivexTrace(ctx: ParseContext, apiName: string, apiArgs: string, globalLine: number): void {\n  if (apiName === 'hivex_open' && !apiArgs.startsWith('=')) {\n    flushHivexSession(ctx.currentHivexSession, ctx.registryHiveAccesses);\n    const hiveMatch = apiArgs.match(/^\"([^\"]+)\"/);\n    if (hiveMatch) {\n      const openMode = apiArgs.includes('write:true') ? 'write' as const : 'read' as const;\n      ctx.currentHivexSession = {\n        hivePath: hiveMatch[1],\n        mode: openMode,\n        openMode,\n        keySegments: [],\n        values: [],\n        pendingGetValueName: null,\n        pendingChildName: null,\n        pendingChildParent: null,\n        failedChild: null,\n        lineNumber: globalLine,\n        rootHandle: '',\n        hasWriteOp: false,\n        firstWriteLine: 0,\n      };\n    }\n  }\n\n  if (apiName === 'hivex_root' && ctx.currentHivexSession) {\n    if (apiArgs.startsWith('= ')) {\n      ctx.currentHivexSession.rootHandle = apiArgs.slice(2).trim();\n    } else {\n      if (ctx.currentHivexSession.keySegments.length > 0 || ctx.currentHivexSession.values.length > 0) {\n        resetHivexTraversal(ctx, ctx.currentHivexSession);\n      }\n    }\n  }\n\n  if (apiName === 'hivex_node_get_child' && ctx.currentHivexSession) {\n    if (apiArgs.startsWith('= ')) {\n      const resultVal = apiArgs.slice(2).trim();\n      if (resultVal !== '0' && ctx.currentHivexSession.pendingChildName) {\n        ctx.currentHivexSession.keySegments.push(ctx.currentHivexSession.pendingChildName);\n      } else if (resultVal === '0' && ctx.currentHivexSession.pendingChildName) {\n        ctx.currentHivexSession.failedChild = ctx.currentHivexSession.pendingChildName;\n      }\n      ctx.currentHivexSession.pendingChildName = null;\n      ctx.currentHivexSession.pendingChildParent = null;\n    } else {\n      const childMatch = apiArgs.match(HIVEX_HANDLE_NAME_RE);\n      if (childMatch) {\n        const parentHandle = childMatch[1];\n        const childName = childMatch[2];\n        if (ctx.currentHivexSession.rootHandle && parentHandle === ctx.currentHivexSession.rootHandle && ctx.currentHivexSession.keySegments.length > 0) {\n          resetHivexTraversal(ctx, ctx.currentHivexSession, { lineNumber: globalLine });\n        }\n        ctx.currentHivexSession.pendingChildName = childName;\n        ctx.currentHivexSession.pendingChildParent = parentHandle;\n      }\n    }\n  }\n\n  if (apiName === 'hivex_node_add_child' && !apiArgs.startsWith('=') && ctx.currentHivexSession) {\n    ctx.currentHivexSession.hasWriteOp = true;\n    if (!ctx.currentHivexSession.firstWriteLine) ctx.currentHivexSession.firstWriteLine = globalLine;\n    const addMatch = apiArgs.match(HIVEX_HANDLE_NAME_RE);\n    if (addMatch) {\n      const parentHandle = addMatch[1];\n      const childName = addMatch[2];\n      if (ctx.currentHivexSession.rootHandle && parentHandle === ctx.currentHivexSession.rootHandle && ctx.currentHivexSession.keySegments.length > 0) {\n        resetHivexTraversal(ctx, ctx.currentHivexSession, {\n          hasWriteOp: true,\n          firstWriteLine: globalLine,\n          lineNumber: globalLine,\n        });\n      }\n      if (ctx.currentHivexSession.failedChild === childName) {\n        ctx.currentHivexSession.failedChild = null;\n      }\n      ctx.currentHivexSession.keySegments.push(childName);\n    }\n  }\n\n  if (apiName === 'hivex_node_get_value' && ctx.currentHivexSession) {\n    if (apiArgs.startsWith('= ')) {\n      const resultVal = apiArgs.slice(2).trim();\n      if (resultVal === '0') {\n        ctx.currentHivexSession.pendingGetValueName = null;\n      }\n    } else {\n      const valNameMatch = apiArgs.match(HIVEX_HANDLE_NAME_RE);\n      if (valNameMatch) {\n        ctx.currentHivexSession.pendingGetValueName = valNameMatch[2];\n      }\n    }\n  }\n\n  if (apiName === 'hivex_value_string' && ctx.currentHivexSession) {\n    if (apiArgs.startsWith('= ')) {\n      const valStr = apiArgs.slice(2).trim();\n      const strMatch = valStr.match(HIVEX_QUOTED_STRING_RE);\n      if (strMatch && ctx.currentHivexSession.pendingGetValueName) {\n        ctx.currentHivexSession.values.push({\n          name: ctx.currentHivexSession.pendingGetValueName,\n          value: strMatch[1],\n          lineNumber: globalLine,\n        });\n        ctx.currentHivexSession.pendingGetValueName = null;\n      }\n    }\n  }\n\n  if (apiName === 'hivex_value_value' && ctx.currentHivexSession) {\n    if (apiArgs.startsWith('= ')) {\n      const valStr = apiArgs.slice(2).trim();\n      const strMatch = valStr.match(HIVEX_QUOTED_STRING_RE);\n      if (strMatch && ctx.currentHivexSession.pendingGetValueName) {\n        ctx.currentHivexSession.values.push({\n          name: ctx.currentHivexSession.pendingGetValueName,\n          value: decodeHivexData(strMatch[1], 1),\n          lineNumber: globalLine,\n        });\n        ctx.currentHivexSession.pendingGetValueName = null;\n      }\n    }\n  }\n\n  if (apiName === 'hivex_value_key' && ctx.currentHivexSession) {\n    if (apiArgs.startsWith('= ')) {\n      const valStr = apiArgs.slice(2).trim();\n      const strMatch = valStr.match(HIVEX_QUOTED_STRING_RE);\n      if (strMatch) {\n        ctx.currentHivexSession.pendingGetValueName = strMatch[1];\n      }\n    }\n  }\n\n  if (apiName === 'hivex_commit' && !apiArgs.startsWith('=') && ctx.currentHivexSession) {\n    ctx.currentHivexSession.hasWriteOp = true;\n    if (!ctx.currentHivexSession.firstWriteLine) ctx.currentHivexSession.firstWriteLine = globalLine;\n    if (ctx.currentHivexSession.values.length > 0 || ctx.currentHivexSession.keySegments.length > 0) {\n      resetHivexTraversal(ctx, ctx.currentHivexSession);\n    }\n  }\n\n  if (apiName === 'hivex_node_set_value' && !apiArgs.startsWith('=') && ctx.currentHivexSession) {\n    ctx.currentHivexSession.hasWriteOp = true;\n    if (!ctx.currentHivexSession.firstWriteLine) ctx.currentHivexSession.firstWriteLine = globalLine;\n    const setMatch = apiArgs.match(/^\\d+\\s+\"([^\"]+)\"\\s+(\\d+)\\s+\"(.+)\"$/);\n    if (setMatch) {\n      const valName = setMatch[1];\n      const regType = parseInt(setMatch[2], 10);\n      const rawData = setMatch[3];\n      ctx.currentHivexSession.values.push({\n        name: valName,\n        value: decodeHivexData(rawData, regType),\n        lineNumber: globalLine,\n      });\n    }\n  }\n\n  if (apiName === 'hivex_close' && !apiArgs.startsWith('=') && ctx.currentHivexSession) {\n    flushHivexSession(ctx.currentHivexSession, ctx.registryHiveAccesses);\n    ctx.currentHivexSession = null;\n  }\n}\n\n// \n// Handler: libguestfs command flush\n// \n\nexport function handleLibguestfsCmdFlush(ctx: ParseContext, line: string): void {\n  if (\n    ctx.pendingLibguestfsCmd.length > 0 &&\n    !line.startsWith('libguestfs:') &&\n    !line.trim().startsWith('\\\\')\n  ) {\n    ctx.hostCommands.push(buildHostCommand(ctx.pendingLibguestfsCmd, ctx.pendingLibguestfsCmdLine));\n    ctx.pendingLibguestfsCmd = [];\n  }\n}\n\n// \n// Handler: guestfsd scope boundaries\n// \n\nexport function handleGuestfsdScope(ctx: ParseContext, line: string): void {\n  if (!line.startsWith('guestfsd:')) return;\n\n  const startMatch = line.match(GUESTFSD_START_RE);\n  if (startMatch) {\n    if (ctx.activeGuestfsd) {\n      attachGuestfsdToApiCall(ctx.activeGuestfsd, ctx.openApiCalls, ctx.completedApiCalls);\n    }\n    ctx.activeGuestfsd = { name: startMatch[1], commands: [] };\n  }\n\n  const endMatch = line.match(GUESTFSD_END_RE);\n  if (endMatch) {\n    const durationSecs = parseFloat(endMatch[2]);\n    if (ctx.activeGuestfsd) {\n      const guestfsdApiName = endMatch[1];\n      const durationQueue = findQueueByApiName(ctx.openApiCalls, guestfsdApiName)\n        || findQueueByApiName(ctx.openApiCalls, ctx.activeGuestfsd.name);\n      if (durationQueue && durationQueue.length > 0) {\n        durationQueue[0].durationSecs = durationSecs;\n      }\n      attachGuestfsdToApiCall(ctx.activeGuestfsd, ctx.openApiCalls, ctx.completedApiCalls);\n      ctx.activeGuestfsd = null;\n    } else {\n      const durationQueue = findQueueByApiName(ctx.openApiCalls, endMatch[1]);\n      if (durationQueue && durationQueue.length > 0) {\n        durationQueue[0].durationSecs = durationSecs;\n      }\n    }\n  }\n}\n\n// \n// Handler: guest commands (command:, commandrvf:, chroot:)\n// \n\nexport function handleGuestCommands(ctx: ParseContext, line: string, globalLine: number): boolean {\n  if (line.startsWith('libguestfs:') || line.startsWith('guestfsd:')) return false;\n\n  const stdoutHeaderMatch = line.match(CMD_STDOUT_RE);\n  if (stdoutHeaderMatch) {\n    ctx.stdoutCapture = { cmdName: stdoutHeaderMatch[1] };\n    return true;\n  }\n\n  const retMatch = line.match(CMD_RETURN_RE);\n  if (retMatch) {\n    const retCode = parseInt(retMatch[2], 10);\n    const cmd = findLastGuestCommand(ctx, retMatch[1]);\n    if (cmd && cmd.returnCode === undefined) cmd.returnCode = retCode;\n    return true;\n  }\n\n  if (line.startsWith('command:')) {\n    const cmdExecMatch = line.match(COMMAND_RE);\n    if (cmdExecMatch) {\n      const args = parseCommandArgs(cmdExecMatch[2]);\n      addGuestCommand(ctx, {\n        command: cmdExecMatch[1],\n        args,\n        source: 'command',\n        stdoutLines: [],\n        lineNumber: globalLine,\n      });\n    }\n  }\n\n  if (line.startsWith('commandrvf:')) {\n    if (!COMMANDRVF_META_RE.test(line)) {\n      const rvfMatch = line.match(COMMANDRVF_EXEC_RE);\n      if (rvfMatch && !isNoisyCommand(rvfMatch[1])) {\n        const args = parseCommandArgs(rvfMatch[2]);\n        addGuestCommand(ctx, {\n          command: rvfMatch[1],\n          args,\n          source: 'commandrvf',\n          stdoutLines: [],\n          lineNumber: globalLine,\n        });\n      }\n    }\n  }\n\n  if (line.startsWith('chroot:')) {\n    const chrootMatch = line.match(CHROOT_RE);\n    if (chrootMatch) {\n      addGuestCommand(ctx, {\n        command: chrootMatch[2],\n        args: [],\n        source: 'chroot',\n        stdoutLines: [],\n        lineNumber: globalLine,\n      });\n    }\n  }\n\n  return false;\n}\n\n// \n// Handler: guest info (i_ lines, inspect blocks)\n// \n\nexport function handleGuestInfo(ctx: ParseContext, line: string): void {\n  const iMatch = line.match(/^i_(\\w+)\\s*=\\s*(.+)$/);\n  if (iMatch) {\n    ctx.guestInfoRaw.set(iMatch[1], iMatch[2].trim());\n  }\n\n  const rootHeaderMatch = line.match(/^(\\/dev\\/\\S+)\\s+\\(\\w+\\):\\s*$/);\n  if (rootHeaderMatch && !ctx.guestInfoRaw.has('root')) {\n    ctx.guestInfoRaw.set('root', rootHeaderMatch[1]);\n  }\n\n  const fsHeaderMatch = line.match(/^fs:\\s+(\\/dev\\/\\S+)\\s+\\(\\w+\\)\\s+role:\\s+(\\w+)/);\n  if (fsHeaderMatch) {\n    if (fsHeaderMatch[2] === 'root' && !ctx.guestInfoRaw.has('root')) {\n      ctx.guestInfoRaw.set('root', fsHeaderMatch[1]);\n    }\n  }\n\n  const indentedMatch = line.match(/^\\s{4}(\\w[\\w\\s]*\\w)\\s*:\\s*(.+)$/);\n  if (indentedMatch) {\n    const key = indentedMatch[1].trim();\n    const val = indentedMatch[2].trim();\n    const keyMap: Record<string, string> = {\n      'type': 'type',\n      'distro': 'distro',\n      'arch': 'arch',\n      'hostname': 'hostname',\n      'version': 'version',\n      'product_name': 'product_name',\n      'product_variant': 'product_variant',\n      'package_format': 'package_format',\n      'package_management': 'package_management',\n      'build ID': 'build_id',\n      'fstab': 'fstab',\n      'drive_mappings': 'drive_mappings',\n      'windows_systemroot': 'windows_systemroot',\n      'windows_software_hive': 'windows_software_hive',\n      'windows_system_hive': 'windows_system_hive',\n      'windows_current_control_set': 'windows_current_control_set',\n    };\n    const mappedKey = keyMap[key];\n    if (mappedKey && !ctx.guestInfoRaw.has(mappedKey)) {\n      ctx.guestInfoRaw.set(mappedKey, val);\n    }\n  }\n}\n\n// \n// Handler: blkid\n// \n\nexport function handleBlkid(ctx: ParseContext, line: string): void {\n  const blkidEntry = parseBlkidLine(line);\n  if (blkidEntry && !ctx.blkidEntries.some((e) => e.device === blkidEntry.device)) {\n    ctx.blkidEntries.push(blkidEntry);\n  }\n}\n\n// \n// Handler: VirtIO Win / file copy tracking\n// \n\nexport function handleFileCopies(ctx: ParseContext, line: string, globalLine: number): void {\n  const isoMatch = line.match(/copy_from_virtio_win:\\s+guest tools source ISO\\s+(\\S+)/);\n  if (isoMatch) {\n    ctx.virtioWinIsoPath = isoMatch[1];\n  }\n\n  const readFileMatch = line.match(/libguestfs: trace: virtio_win: read_file \"(\\/\\/\\/[^\"]+)\"/);\n  if (readFileMatch) {\n    ctx.pendingVirtioWinRead = { source: readFileMatch[1], sizeBytes: null, lineNumber: globalLine };\n  }\n\n  if (ctx.pendingVirtioWinRead) {\n    const readSize = extractOriginalSize(line);\n    if (readSize !== null) {\n      ctx.pendingVirtioWinRead.sizeBytes = readSize;\n    }\n  }\n\n  const v2vReadFileMatch = line.match(/libguestfs: trace: v2v: read_file \"([^\"]+)\"/);\n  if (v2vReadFileMatch && !line.includes('read_file =')) {\n    const readPath = v2vReadFileMatch[1];\n    ctx.lastV2VReadFilePath = readPath;\n    ctx.pendingV2VReads.set(readPath, { content: null, sizeBytes: null, lineNumber: globalLine });\n  }\n\n  if (ctx.lastV2VReadFilePath) {\n    const v2vReadResultMatch = line.match(/libguestfs: trace: v2v: read_file = /);\n    if (v2vReadResultMatch) {\n      const pending = ctx.pendingV2VReads.get(ctx.lastV2VReadFilePath);\n      if (pending) {\n        const pendingSize = extractOriginalSize(line);\n        if (pendingSize !== null) {\n          pending.sizeBytes = pendingSize;\n        }\n        const contentResult = extractReadFileContent(line);\n        if (contentResult !== null) {\n          pending.content = contentResult;\n        }\n      }\n      ctx.lastV2VReadFilePath = null;\n    }\n  }\n\n  const writeMatch = line.match(/libguestfs: trace: v2v: write \"([^\"]+)\"/);\n  if (writeMatch) {\n    const dest = writeMatch[1];\n    const writeSize = extractOriginalSize(line);\n    const contentTruncated = line.includes('<truncated,');\n    const contentResult = extractWriteContent(line, dest);\n\n    if (ctx.pendingVirtioWinRead) {\n      ctx.fileCopies.push({\n        source: ctx.pendingVirtioWinRead.source,\n        destination: dest,\n        sizeBytes: ctx.pendingVirtioWinRead.sizeBytes ?? writeSize,\n        origin: 'virtio_win',\n        content: null,\n        contentTruncated: false,\n        lineNumber: ctx.pendingVirtioWinRead.lineNumber,\n      });\n      ctx.pendingVirtioWinRead = null;\n    } else if (ctx.pendingV2VReads.has(dest)) {\n      const readInfo = ctx.pendingV2VReads.get(dest)!;\n      ctx.fileCopies.push({\n        source: dest,\n        destination: dest,\n        sizeBytes: readInfo.sizeBytes ?? writeSize,\n        origin: 'guest',\n        content: contentResult ?? readInfo.content,\n        contentTruncated,\n        lineNumber: readInfo.lineNumber,\n      });\n      ctx.pendingV2VReads.delete(dest);\n    } else {\n      ctx.fileCopies.push({\n        source: '(generated)',\n        destination: dest,\n        sizeBytes: writeSize,\n        origin: 'script',\n        content: contentResult,\n        contentTruncated,\n        lineNumber: globalLine,\n      });\n    }\n  }\n\n  const uploadMatch = line.match(/libguestfs: trace: v2v: upload \"([^\"]+)\" \"([^\"]+)\"/);\n  if (uploadMatch) {\n    const src = uploadMatch[1];\n    const dest = uploadMatch[2];\n    if (!src.startsWith('/tmp/')) {\n      ctx.fileCopies.push({\n        source: src,\n        destination: dest,\n        sizeBytes: null,\n        origin: 'virt-tools',\n        content: null,\n        contentTruncated: false,\n        lineNumber: globalLine,\n      });\n    }\n  }\n}\n\n// \n// Handler: errors & warnings\n// \n\nexport function handleErrors(ctx: ParseContext, line: string, globalLine: number): void {\n  if (ERROR_RE.test(line) && !isErrorFalsePositive(line)) {\n    const source = extractSource(line);\n    ctx.errors.push({\n      level: 'error',\n      source,\n      message: line,\n      lineNumber: globalLine,\n      rawLine: line,\n    });\n  } else if (WARNING_RE.test(line)) {\n    const source = extractSource(line);\n    ctx.errors.push({\n      level: 'warning',\n      source,\n      message: line,\n      lineNumber: globalLine,\n      rawLine: line,\n    });\n  }\n}\n\n// \n// Flush pending state after the loop\n// \n\nexport function flushPendingState(ctx: ParseContext): void {\n  if (ctx.pendingLibguestfsCmd.length > 0) {\n    ctx.hostCommands.push(buildHostCommand(ctx.pendingLibguestfsCmd, ctx.pendingLibguestfsCmdLine));\n  }\n  if (ctx.activeGuestfsd) {\n    attachGuestfsdToApiCall(ctx.activeGuestfsd, ctx.openApiCalls, ctx.completedApiCalls);\n  }\n  if (ctx.currentNbdkit) {\n    finalizeNbdkit(ctx.currentNbdkit, ctx.nbdkitMap, ctx.globalLineOffset + ctx.sectionLines.length - 1);\n  }\n\n  // Move remaining open API calls to completed\n  for (const queue of ctx.openApiCalls.values()) {\n    ctx.completedApiCalls.push(...queue);\n  }\n\n  // Sort by line number\n  ctx.completedApiCalls.sort((a, b) => a.lineNumber - b.lineNumber);\n\n  // Build guest info\n  if (ctx.guestInfoRaw.size > 0 && (ctx.guestInfoRaw.has('root') || ctx.guestInfoRaw.has('type') || ctx.guestInfoRaw.has('distro'))) {\n    ctx.guestInfo = buildGuestInfo(ctx.guestInfoRaw);\n    ctx.guestInfo.blkid = ctx.blkidEntries;\n  }\n\n  // Flush unclosed hivex session\n  flushHivexSession(ctx.currentHivexSession, ctx.registryHiveAccesses);\n  ctx.currentHivexSession = null;\n\n  // Collect nbdkit connections\n  ctx.nbdkitConnections.push(...ctx.nbdkitMap.values());\n\n  // Build disk summary from nbdkit connections\n  ctx.nbdkitConnections.forEach((conn, idx) => {\n    ctx.diskSummary.disks.push({\n      index: idx + 1,\n      sizeBytes: conn.backingSize,\n      sourceFile: conn.diskFile || undefined,\n      transportMode: conn.transportMode,\n      server: conn.server,\n      vmMoref: conn.vmMoref,\n    });\n  });\n}\n\n// \n// Re-export categorizeLine for the main parser\n// \n\nexport { categorizeLine };\n","import type {\n  V2VParsedData,\n  V2VToolRun,\n  V2VLogType,\n  LibguestfsInfo,\n} from '../types/v2v';\n\nimport { inferExitStatus } from './v2v/v2vHelpers';\n\nimport {\n  createParseContext,\n  categorizeLine,\n  handleStdoutCapture,\n  handlePipelineStages,\n  handleMonitorProgress,\n  handleVersionsAndDiskInfo,\n  handleLibvirtXML,\n  handleNbdkit,\n  handleLibguestfsTrace,\n  handleLibguestfsCmdFlush,\n  handleGuestfsdScope,\n  handleGuestCommands,\n  handleGuestInfo,\n  handleBlkid,\n  handleFileCopies,\n  handleErrors,\n  flushPendingState,\n} from './v2v/parseHandlers';\n\n// \n// Regex patterns (preprocessing / boundary detection only)\n// \n\n/** Container / k8s timestamp prefix: `2026-01-21T00:57:24.837772290Z ` */\nconst CONTAINER_TS_PREFIX_RE = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z\\s+/;\n\n/** `Building command: tool [args]` (with space, bracket args) */\nconst BUILD_CMD_SPACE_RE = /^Building command:\\s*(\\S+)\\s+\\[(.*)]/;\n\n/** `Building command:tool[args]` (no space, bracket args) */\nconst BUILD_CMD_NOSPACE_RE = /Building command:(\\S+?)\\[([^\\]]*)\\]/g;\n\n// \n// Detection\n// \n\n/**\n * Detect whether a plain-text file is a virt-v2v / virt-v2v-inspector log.\n * Checks the first ~10 lines for characteristic markers.\n */\nexport function isV2VLog(content: string): boolean {\n  // Look at the first 3000 chars (covers the first few lines even when they\n  // are long, like the concatenated Building-command line in virt-v2v.logs).\n  // Strip optional container/k8s timestamp prefixes so the markers are visible.\n  const head = content\n    .slice(0, 3000)\n    .replace(CONTAINER_TS_PREFIX_RE, '')\n    .replace(/\\n\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z\\s+/g, '\\n');\n  // MTV wrapper: \"Building command: virt-v2v [...]\"\n  if (/Building command[:\\s]*virt-v2v/i.test(head)) return true;\n  // MTV info prefix: \"info: virt-v2v ...\"\n  if (/^info:\\s*virt-v2v/m.test(head)) return true;\n  // Raw virt-v2v output: \"virt-v2v: ...\" (version line, stage headers, etc.)\n  if (/^virt-v2v:/m.test(head)) return true;\n  // Tool-specific names\n  if (/virt-v2v-in-place/i.test(head)) return true;\n  if (/virt-v2v-inspector/i.test(head)) return true;\n  // libguestfs trace lines (present in verbose v2v output)\n  if (/^libguestfs:\\s+trace:/m.test(head)) return true;\n  return false;\n}\n\n// \n// Main parser\n// \n\nexport function parseV2VLog(content: string): V2VParsedData {\n  try {\n    return parseV2VLogImpl(content);\n  } catch (err) {\n    console.error('parseV2VLog failed:', err);\n    return { toolRuns: [], totalLines: 0 };\n  }\n}\n\nfunction parseV2VLogImpl(content: string): V2VParsedData {\n  const rawLines = content.split('\\n');\n\n  // Pre-process: split concatenated Building-command lines (virt-v2v.logs style)\n  const lines = preprocessLines(rawLines);\n  const totalLines = lines.length;\n\n  // Identify tool-run boundaries\n  const boundaries = findToolRunBoundaries(lines);\n\n  // Parse each tool-run section\n  const toolRuns: V2VToolRun[] = [];\n  for (let i = 0; i < boundaries.length; i++) {\n    const start = boundaries[i].lineIndex;\n    const end = i + 1 < boundaries.length ? boundaries[i + 1].lineIndex : totalLines;\n    const sectionLines = lines.slice(start, end);\n\n    const toolRun = parseToolRunSection(\n      sectionLines,\n      boundaries[i].tool,\n      boundaries[i].commandLine,\n      start,\n    );\n    toolRuns.push(toolRun);\n  }\n\n  // If no boundaries found (e.g. log starts without Building command),\n  // treat entire file as single unknown tool run\n  if (toolRuns.length === 0) {\n    const tool = detectToolFromContent(lines);\n    const toolRun = parseToolRunSection(lines, tool, '', 0);\n    toolRuns.push(toolRun);\n  }\n\n  return { toolRuns, totalLines };\n}\n\n// \n// Pre-processing\n// \n\n/**\n * Handle lines that have multiple `Building command:` entries concatenated\n * on a single line (seen in virt-v2v.logs).\n */\nfunction preprocessLines(rawLines: string[]): string[] {\n  const result: string[] = [];\n  for (let line of rawLines) {\n    // Strip optional container / k8s timestamp prefix\n    // e.g. \"2026-01-21T00:57:24.837772290Z Building command: ...\"\n    line = line.replace(CONTAINER_TS_PREFIX_RE, '');\n\n    // Check if line has multiple Building command: entries\n    const parts = splitConcatenatedBuildCommands(line);\n    if (parts.length > 1) {\n      result.push(...parts);\n      continue;\n    }\n\n    // Recover corrupted lines where libguestfs trace is embedded after a\n    // garbled prefix (e.g. \"guestfsd: =libguestfs: trace: ...\" or\n    // \"gulibguestfs: trace: ...\"). Extract the trace part as a separate line.\n    if (!line.startsWith('libguestfs:') && line.includes('libguestfs: trace:')) {\n      const traceIdx = line.indexOf('libguestfs: trace:');\n      const prefix = line.slice(0, traceIdx).trim();\n      const tracePart = line.slice(traceIdx);\n      if (prefix) result.push(prefix);\n      result.push(tracePart);\n      continue;\n    }\n\n    // Handle interleaved libguestfs trace lines within a single line, e.g.:\n    // \"libguestfs: trace: v2v: aug_setlibguestfs: trace: v2v: aug_get ...\"\n    // Split at the second occurrence of \"libguestfs: trace:\"\n    if (line.startsWith('libguestfs: trace:')) {\n      const secondIdx = line.indexOf('libguestfs: trace:', 1);\n      if (secondIdx > 0) {\n        result.push(line.slice(0, secondIdx).trim());\n        result.push(line.slice(secondIdx));\n        continue;\n      }\n    }\n\n    result.push(line);\n  }\n  return result;\n}\n\nfunction splitConcatenatedBuildCommands(line: string): string[] {\n  // Match all `Building command:name[args]` in the line\n  const matches = [...line.matchAll(BUILD_CMD_NOSPACE_RE)];\n  if (matches.length <= 1) {\n    // Also check for `Building command: name [args]` style\n    const spaceMatch = line.match(/Building command:/g);\n    if (!spaceMatch || spaceMatch.length <= 1) return [line];\n  }\n\n  // Split by `Building command:` boundaries\n  const parts: string[] = [];\n  const indices: number[] = [];\n  let searchFrom = 0;\n\n  while (true) {\n    const idx = line.indexOf('Building command:', searchFrom);\n    if (idx === -1) break;\n    indices.push(idx);\n    searchFrom = idx + 17; // length of \"Building command:\"\n  }\n\n  for (let i = 0; i < indices.length; i++) {\n    const start = indices[i];\n    const end = i + 1 < indices.length ? indices[i + 1] : line.length;\n    const part = line.slice(start, end).trim();\n    if (part) parts.push(part);\n  }\n\n  // If there's content before the first Building command:, keep it\n  if (indices.length > 0 && indices[0] > 0) {\n    const prefix = line.slice(0, indices[0]).trim();\n    if (prefix) parts.unshift(prefix);\n  }\n\n  return parts.length > 0 ? parts : [line];\n}\n\n// \n// Boundary detection\n// \n\ninterface ToolBoundary {\n  lineIndex: number;\n  tool: V2VLogType;\n  commandLine: string;\n}\n\nfunction findToolRunBoundaries(lines: string[]): ToolBoundary[] {\n  const boundaries: ToolBoundary[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    // `Building command: tool [args]`\n    const spaceMatch = line.match(BUILD_CMD_SPACE_RE);\n    if (spaceMatch) {\n      const tool = classifyTool(spaceMatch[1]);\n      if (tool) {\n        boundaries.push({ lineIndex: i, tool, commandLine: spaceMatch[2] });\n        continue;\n      }\n    }\n\n    // `Building command:tool[args]`\n    BUILD_CMD_NOSPACE_RE.lastIndex = 0;\n    const noSpaceMatch = BUILD_CMD_NOSPACE_RE.exec(line);\n    if (noSpaceMatch) {\n      const tool = classifyTool(noSpaceMatch[1]);\n      if (tool) {\n        boundaries.push({ lineIndex: i, tool, commandLine: noSpaceMatch[2] });\n        continue;\n      }\n    }\n  }\n\n  return boundaries;\n}\n\nfunction classifyTool(name: string): V2VLogType | null {\n  const lower = name.toLowerCase();\n  if (lower === 'virt-v2v-in-place') return 'virt-v2v-in-place';\n  if (lower === 'virt-v2v-inspector') return 'virt-v2v-inspector';\n  if (lower === 'virt-v2v-customize' || lower === 'virt-customize')\n    return 'virt-v2v-customize';\n  if (lower === 'virt-v2v') return 'virt-v2v';\n  // Skip monitor and other non-main tools\n  if (lower.includes('monitor')) return null;\n  // Fallback: if it contains virt-v2v\n  if (lower.includes('virt-v2v')) return 'virt-v2v';\n  return null;\n}\n\nfunction detectToolFromContent(lines: string[]): V2VLogType {\n  const head = lines.slice(0, 20).join('\\n');\n  if (/virt-v2v-in-place/i.test(head)) return 'virt-v2v-in-place';\n  if (/virt-v2v-inspector/i.test(head)) return 'virt-v2v-inspector';\n  if (/virt-v2v-customize|virt-customize/i.test(head)) return 'virt-v2v-customize';\n  return 'virt-v2v';\n}\n\n// \n// Section parser\n// \n\nfunction parseToolRunSection(\n  sectionLines: string[],\n  tool: V2VLogType,\n  commandLine: string,\n  globalLineOffset: number,\n): V2VToolRun {\n  const ctx = createParseContext(sectionLines, globalLineOffset);\n\n  for (let i = 0; i < sectionLines.length; i++) {\n    const line = sectionLines[i];\n    const globalLine = globalLineOffset + i;\n\n    if (!line.trim()) {\n      ctx.lineCategories.push('other');\n      continue;\n    }\n\n    // Determine line category\n    const category = categorizeLine(line);\n    ctx.lineCategories.push(category);\n\n    // Stdout capture mode  consumes the line if active\n    if (handleStdoutCapture(ctx, line)) continue;\n\n    // Pipeline stages\n    handlePipelineStages(ctx, line, globalLine);\n\n    // Monitor progress\n    handleMonitorProgress(ctx, line, globalLine);\n\n    // Component versions and host free space\n    handleVersionsAndDiskInfo(ctx, line);\n\n    // Libvirt XML capture\n    handleLibvirtXML(ctx, line);\n\n    // NBDKIT\n    handleNbdkit(ctx, line, globalLine);\n\n    // Libguestfs trace & config (includes hivex, API calls)\n    handleLibguestfsTrace(ctx, line, globalLine);\n\n    // Libguestfs command: run: continuation flush\n    handleLibguestfsCmdFlush(ctx, line);\n\n    // Guestfsd scope boundaries\n    handleGuestfsdScope(ctx, line);\n\n    // Guest commands  may consume the line (stdout header, return code)\n    if (handleGuestCommands(ctx, line, globalLine)) continue;\n\n    // Guest inspection info\n    handleGuestInfo(ctx, line);\n\n    // blkid output\n    handleBlkid(ctx, line);\n\n    // VirtIO Win / file copy tracking\n    handleFileCopies(ctx, line, globalLine);\n\n    // Errors & Warnings\n    handleErrors(ctx, line, globalLine);\n  }\n\n  // Flush all pending state\n  flushPendingState(ctx);\n\n  const libguestfs: LibguestfsInfo = {\n    backend: ctx.lgBackend,\n    identifier: ctx.lgIdentifier,\n    memsize: ctx.lgMemsize,\n    smp: ctx.lgSmp,\n    drives: ctx.lgDrives,\n    apiCalls: ctx.lgApiCalls,\n    launchLines: ctx.lgLaunchLines,\n  };\n\n  const exitStatus = inferExitStatus(ctx.stages, ctx.errors, sectionLines);\n\n  return {\n    tool,\n    commandLine,\n    exitStatus,\n    startLine: globalLineOffset,\n    endLine: globalLineOffset + sectionLines.length - 1,\n    stages: ctx.stages,\n    diskProgress: ctx.diskProgress,\n    nbdkitConnections: ctx.nbdkitConnections,\n    libguestfs,\n    apiCalls: ctx.completedApiCalls,\n    hostCommands: ctx.hostCommands,\n    guestInfo: ctx.guestInfo,\n    installedApps: ctx.installedApps,\n    registryHiveAccesses: ctx.registryHiveAccesses,\n    virtioWin: {\n      isoPath: ctx.virtioWinIsoPath,\n      fileCopies: ctx.fileCopies,\n    },\n    versions: ctx.versions,\n    diskSummary: ctx.diskSummary,\n    sourceVM: ctx.sourceVM,\n    errors: ctx.errors,\n    rawLines: sectionLines,\n    lineCategories: ctx.lineCategories,\n  };\n}\n","/**\n * Merge two ParsedData results into one.\n *\n * Used for:\n *  - Combining log pipeline + YAML pipeline results\n *  - Accumulating results from multiple files / archives\n *\n * Strategy for duplicate plans (same namespace/name):\n *  - The plan with real log data (VMs not from YAML) is used as the base\n *  - The other plan enriches it with spec, VM metadata, status, etc.\n *  - If neither or both have log data, the first argument wins as base\n */\n\nimport type { ParsedData, Plan, VM, Summary } from '../types';\n\n//  Public API \n\n/**\n * Merge two ParsedData into a single combined result.\n * Either (or both) inputs may be null.\n */\nexport function mergeResults(\n  a: ParsedData | null,\n  b: ParsedData | null,\n): ParsedData {\n  if (!a && !b) return emptyResult();\n  if (!a) return b!;\n  if (!b) return a;\n  return mergeBoth(a, b);\n}\n\n//  Deduplication \n\nfunction deduplicateMaps<T extends { name: string; namespace: string }>(a: T[], b: T[]): T[] {\n  const seen = new Set(a.map(m => `${m.namespace}/${m.name}`));\n  const result = [...a];\n  for (const item of b) {\n    const key = `${item.namespace}/${item.name}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(item);\n    }\n  }\n  return result;\n}\n\n//  Merge logic \n\nfunction mergeBoth(dataA: ParsedData, dataB: ParsedData): ParsedData {\n  // Index plans from B by key\n  const bPlanMap = new Map<string, Plan>();\n  for (const plan of dataB.plans) {\n    bPlanMap.set(planKey(plan), plan);\n  }\n\n  const mergedPlans: Plan[] = [];\n  const matchedKeys = new Set<string>();\n\n  // Walk plans from A, merge with B if matched\n  for (const planA of dataA.plans) {\n    const key = planKey(planA);\n    const planB = bPlanMap.get(key);\n\n    if (planB) {\n      matchedKeys.add(key);\n      mergedPlans.push(mergePlans(planA, planB));\n    } else {\n      mergedPlans.push(planA);\n    }\n  }\n\n  // Add plans only in B\n  for (const planB of dataB.plans) {\n    if (!matchedKeys.has(planKey(planB))) {\n      mergedPlans.push(planB);\n    }\n  }\n\n  // Combine events and sort\n  const events = [...dataA.events, ...dataB.events];\n  events.sort((a, b) => a.timestamp.localeCompare(b.timestamp));\n\n  // Recompute stats\n  const stats = {\n    totalLines: dataA.stats.totalLines + dataB.stats.totalLines,\n    parsedLines: dataA.stats.parsedLines + dataB.stats.parsedLines,\n    errorLines: dataA.stats.errorLines + dataB.stats.errorLines,\n    duplicateLines: dataA.stats.duplicateLines + dataB.stats.duplicateLines,\n    plansFound: mergedPlans.length,\n    vmsFound: mergedPlans.reduce(\n      (sum, p) => sum + Object.keys(p.vms).length,\n      0,\n    ),\n  };\n\n  const summary = computeSummary(mergedPlans);\n\n  // Combine network and storage maps (deduplicated by namespace/name)\n  const networkMaps = deduplicateMaps(dataA.networkMaps || [], dataB.networkMaps || []);\n  const storageMaps = deduplicateMaps(dataA.storageMaps || [], dataB.storageMaps || []);\n\n  return { plans: mergedPlans, events, stats, summary, networkMaps, storageMaps };\n}\n\n//  Plan merging \n\n/**\n * Check whether a plan has real log-pipeline data (VMs not from YAML).\n */\nfunction hasLogData(plan: Plan): boolean {\n  return Object.values(plan.vms).some(vm => !vm.fromYaml);\n}\n\n/**\n * Merge two plans with the same namespace/name.\n *\n * The plan with real log-pipeline data is used as the base (richer events,\n * phase logs, raw entries). The other enriches it with spec, VM metadata,\n * and a more accurate status if the base status is inconclusive.\n *\n * If both or neither have log data, the first argument is used as base.\n */\nfunction mergePlans(planA: Plan, planB: Plan): Plan {\n  // Pick the log-derived plan as base, YAML-derived as enrichment\n  const bHasLogs = hasLogData(planB);\n  const aHasLogs = hasLogData(planA);\n  const [base, other] = bHasLogs && !aHasLogs ? [planB, planA] : [planA, planB];\n\n  const merged: Plan = { ...base };\n\n  // Spec: take whichever has it\n  if (other.spec && !merged.spec) {\n    merged.spec = other.spec;\n  }\n\n  // Archived: true if either says so\n  if (other.archived) {\n    merged.archived = true;\n  }\n\n  // Status: if base is inconclusive, prefer other's definitive status\n  if (\n    (merged.status === 'Pending' || merged.status === 'Ready') &&\n    other.status !== 'Pending' &&\n    other.status !== 'Ready'\n  ) {\n    merged.status = other.status;\n  }\n\n  // Conditions: merge, prefer base but add missing from other\n  if (other.conditions.length > 0) {\n    const existingTypes = new Set(merged.conditions.map(c => c.type));\n    for (const cond of other.conditions) {\n      if (!existingTypes.has(cond.type)) {\n        merged.conditions.push(cond);\n      }\n    }\n  }\n\n  // Errors: add unique errors from other\n  if (other.errors.length > 0 && merged.errors.length === 0) {\n    merged.errors = [...other.errors];\n  }\n\n  // Panics: add from other if base has none\n  if (other.panics.length > 0 && merged.panics.length === 0) {\n    merged.panics = [...other.panics];\n  }\n\n  // VMs: merge each VM\n  for (const [vmId, otherVM] of Object.entries(other.vms)) {\n    const baseVM = merged.vms[vmId];\n    if (baseVM) {\n      enrichVM(baseVM, otherVM);\n    } else {\n      merged.vms[vmId] = otherVM;\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Enrich a base VM with metadata from another VM.\n * Fills in fields that are missing from the base.\n * Mutates baseVM in place.\n */\nfunction enrichVM(baseVM: VM, otherVM: VM): void {\n  if (otherVM.operatingSystem && !baseVM.operatingSystem) {\n    baseVM.operatingSystem = otherVM.operatingSystem;\n  }\n  if (otherVM.restorePowerState && !baseVM.restorePowerState) {\n    baseVM.restorePowerState = otherVM.restorePowerState;\n  }\n  if (otherVM.newName && !baseVM.newName) {\n    baseVM.newName = otherVM.newName;\n  }\n  if (otherVM.error && !baseVM.error) {\n    baseVM.error = otherVM.error;\n  }\n  if (otherVM.conditions && (!baseVM.conditions || baseVM.conditions.length === 0)) {\n    baseVM.conditions = otherVM.conditions;\n  }\n  if (otherVM.warmInfo && !baseVM.warmInfo) {\n    baseVM.warmInfo = otherVM.warmInfo;\n    baseVM.precopyCount = otherVM.precopyCount;\n  }\n}\n\n//  Helpers \n\nfunction planKey(plan: Plan): string {\n  return `${plan.namespace}/${plan.name}`;\n}\n\nfunction computeSummary(plans: Plan[]): Summary {\n  const summary: Summary = {\n    totalPlans: plans.length,\n    running: 0,\n    succeeded: 0,\n    failed: 0,\n    archived: 0,\n    pending: 0,\n  };\n\n  for (const plan of plans) {\n    if (plan.archived) summary.archived++;\n    switch (plan.status) {\n      case 'Running':\n        summary.running++;\n        break;\n      case 'Succeeded':\n        summary.succeeded++;\n        break;\n      case 'Failed':\n        summary.failed++;\n        break;\n      case 'Pending':\n      case 'Ready':\n        summary.pending++;\n        break;\n    }\n  }\n\n  return summary;\n}\n\nfunction emptyResult(): ParsedData {\n  return {\n    plans: [],\n    events: [],\n    stats: {\n      totalLines: 0,\n      parsedLines: 0,\n      errorLines: 0,\n      duplicateLines: 0,\n      plansFound: 0,\n      vmsFound: 0,\n    },\n    summary: {\n      totalPlans: 0,\n      running: 0,\n      succeeded: 0,\n      failed: 0,\n      archived: 0,\n      pending: 0,\n    },\n    networkMaps: [],\n    storageMaps: [],\n  };\n}\n","/**\n * V2V path classification for archive files.\n *\n * Extracted from archiveProcessor.ts for testability.\n * Classifies archive paths as V2V log files based on path patterns.\n */\n\n/**\n * Path pattern that identifies virt-v2v log files inside a must-gather.\n *\n * Matches paths like:\n *   namespaces/.../pods/planName-vm-NNNN-suffix/virt-v2v/.../logs/current.log\n *   namespaces/.../logs/planName-vm-NNNN-suffix/current.log\n *\n * Captures: [1] = target namespace, [2] = plan name, [3] = VM id (numeric part)\n */\nexport const V2V_PATH_RE = /namespaces\\/([^/]+)\\/(?:pods|logs)\\/(.+)-vm-(\\d+)-[a-z0-9][-a-z0-9]*\\//;\n\n/** Extensions that are never V2V log files, even when found under a V2V pod path. */\nexport const NON_LOG_EXTENSIONS = ['.yaml', '.yml', '.json', '.xml', '.html', '.css', '.js', '.png', '.jpg', '.gif', '.pdf'];\n\n/**\n * Check whether a file path looks like a virt-v2v log based on the archive path.\n * This catches V2V logs even when the first few KB of content don't contain\n * recognisable V2V markers (e.g. heavy container-runtime timestamp prefixes).\n *\n * Files with known non-log extensions (e.g. `.yaml`) are excluded  pod\n * directories often contain resource YAML alongside the actual logs.\n */\nexport function isV2VLogByPath(path: string): boolean {\n  const lower = path.toLowerCase();\n\n  // Never classify non-log files as V2V logs by path alone\n  if (NON_LOG_EXTENSIONS.some((ext) => lower.endsWith(ext))) return false;\n\n  if (V2V_PATH_RE.test(path)) return true;\n  // Also match if the path literally contains \"virt-v2v\" as a directory\n  return lower.includes('/virt-v2v/') || lower.includes('/virt-v2v-inspector/');\n}\n\n/**\n * Extract plan name and VM ID from a V2V archive path.\n *\n * Examples:\n *   `wmsql2-dev-take2-vm-5451-h2fmt`  planName=`wmsql2-dev-take2`, vmId=`vm-5451`\n *   `ccm02220-vm-10975-5kxtj`  planName=`ccm02220`, vmId=`vm-10975`\n */\nexport function extractV2VPathMeta(path: string): { planName?: string; vmId?: string } {\n  const match = V2V_PATH_RE.exec(path);\n  if (!match) return {};\n  return {\n    planName: match[2],\n    vmId: `vm-${match[3]}`,\n  };\n}\n","/**\n * Generic content-based file discovery inside extracted archives.\n *\n * Classifies files by inspecting their content (not their path) and\n * runs them through the appropriate parsing pipeline. Works with any\n * archive layout: MTV must-gather, cluster must-gather, `oc adm inspect`,\n * namespace dumps, etc.\n */\n\nimport type { TarEntry } from './tarExtractor';\nimport type { ParsedData, ArchiveResult } from '../types';\nimport type { V2VFileEntry } from '../types/v2v';\nimport { extractArchive } from './tarExtractor';\nimport { parseLogFile } from './logParser';\nimport { parsePlanYaml } from './planYamlParser';\nimport { isV2VLog, parseV2VLog } from './v2vLogParser';\nimport { mergeResults } from './mergeResults';\nimport { V2V_PATH_RE, isV2VLogByPath } from './v2v/pathClassifier';\n\nexport type ProgressCallback = (stage: string, detail?: string) => void;\n\nexport type { ArchiveResult };\n\n//  Content-based classifiers \n\n/** Signatures that identify forklift-controller JSON log lines */\nconst LOG_SIGNATURES = [\n  '\"logger\":\"plan|',\n  '\"logger\": \"plan|',\n  '\"controller\":\"plan\"',\n  '\"controller\": \"plan\"',\n];\n\n/**\n * Maximum bytes to check for content-based classification.\n * Checking only the first 8 KB is sufficient  if the first few hundred\n * log lines don't contain a forklift signature the file is not a forklift log.\n */\nconst CLASSIFY_CHECK_BYTES = 8 * 1024;\n\n/**\n * Check whether a file looks like forklift-controller JSON log output.\n *\n * Optimisation: only scans the first CLASSIFY_CHECK_BYTES of the content\n * to avoid scanning multi-megabyte files that are clearly not forklift logs.\n *\n * Primary check: content contains one of the distinctive log signatures.\n * Fallback: the path mentions \"forklift-controller\" and the first\n * non-empty line starts with '{' (JSON lines).\n */\nfunction isForkliftLogFile(entry: TarEntry): boolean {\n  // Use only the prefix for the signature scan\n  const sample = entry.content.length > CLASSIFY_CHECK_BYTES\n    ? entry.content.slice(0, CLASSIFY_CHECK_BYTES)\n    : entry.content;\n\n  for (const sig of LOG_SIGNATURES) {\n    if (sample.includes(sig)) return true;\n  }\n\n  // Fallback: path hint + JSON-lines shape (still fast, only checks first line)\n  if (entry.path.toLowerCase().includes('forklift-controller')) {\n    const firstLine = sample.trimStart().split('\\n', 1)[0]?.trim();\n    if (firstLine?.startsWith('{')) return true;\n  }\n\n  return false;\n}\n\n// V2V_PATH_RE, isV2VLogByPath imported from ./v2v/pathClassifier\n\n/**\n * Patterns that identify Forklift Kubernetes resources.\n * Both `kind: Plan` / `kind:Plan` variants are covered, plus NetworkMap and StorageMap.\n */\nconst PLAN_KIND_RE = /kind:\\s*Plan\\b/;\nconst NETWORKMAP_KIND_RE = /kind:\\s*NetworkMap\\b/;\nconst STORAGEMAP_KIND_RE = /kind:\\s*StorageMap\\b/;\nconst FORKLIFT_API_RE = /forklift\\.konveyor\\.io/;\n\n/**\n * Check whether a file contains a Forklift YAML resource (Plan, NetworkMap, or StorageMap).\n * Only checks the first CLASSIFY_CHECK_BYTES for large files.\n */\nfunction isForkliftYamlFile(entry: TarEntry): boolean {\n  const sample = entry.content.length > CLASSIFY_CHECK_BYTES\n    ? entry.content.slice(0, CLASSIFY_CHECK_BYTES)\n    : entry.content;\n  if (!FORKLIFT_API_RE.test(sample)) return false;\n  return PLAN_KIND_RE.test(sample) || NETWORKMAP_KIND_RE.test(sample) || STORAGEMAP_KIND_RE.test(sample);\n}\n\n//  Public API \n\n/**\n * Process an uploaded archive file end-to-end:\n *   1. Extract (recursively for nested tars)\n *   2. Classify files by content\n *   3. Parse with the appropriate pipeline(s)\n *   4. Merge and return\n *\n * @param file        The archive File to process\n * @param onProgress  Optional callback for reporting progress stages\n */\nexport async function processArchive(\n  file: File,\n  onProgress?: ProgressCallback,\n): Promise<ArchiveResult> {\n  try {\n    return await processArchiveImpl(file, onProgress);\n  } catch (err) {\n    console.error('processArchive failed:', err);\n    return {\n      logFiles: [],\n      yamlFiles: [],\n      v2vFiles: [],\n      v2vFileEntries: [],\n      parsedData: mergeResults(null, null),\n    };\n  }\n}\n\nasync function processArchiveImpl(\n  file: File,\n  onProgress?: ProgressCallback,\n): Promise<ArchiveResult> {\n  // 1. Extract all files (handles nested tars/gzips/zips)\n  onProgress?.('Extracting archive...', file.name);\n  const entries = await extractArchive(file);\n\n  // 2. Classify\n  onProgress?.('Classifying files...', `${entries.length} files extracted`);\n  const logEntries: TarEntry[] = [];\n  const yamlEntries: TarEntry[] = [];\n  const v2vEntries: TarEntry[] = [];\n\n  for (const entry of entries) {\n    if (isForkliftLogFile(entry)) {\n      logEntries.push(entry);\n    } else if (isForkliftYamlFile(entry)) {\n      yamlEntries.push(entry);\n    } else if (\n      isV2VLogByPath(entry.path) ||\n      isV2VLog(entry.content.length > CLASSIFY_CHECK_BYTES\n        ? entry.content.slice(0, CLASSIFY_CHECK_BYTES)\n        : entry.content)\n    ) {\n      v2vEntries.push(entry);\n    }\n  }\n\n  // 3. Parse each category\n  let logResult: ParsedData | null = null;\n  let yamlResult: ParsedData | null = null;\n  const v2vFileEntries: V2VFileEntry[] = [];\n\n  if (logEntries.length > 0) {\n    onProgress?.('Parsing controller logs...', `${logEntries.length} file${logEntries.length !== 1 ? 's' : ''}`);\n    logResult = parseLogFilesIndividually(logEntries);\n  }\n\n  if (yamlEntries.length > 0) {\n    onProgress?.('Parsing Forklift YAMLs...', `${yamlEntries.length} file${yamlEntries.length !== 1 ? 's' : ''}`);\n    const combined = yamlEntries.map((e) => e.content).join('\\n---\\n');\n    yamlResult = parsePlanYaml(combined);\n  }\n\n  if (v2vEntries.length > 0) {\n    onProgress?.('Parsing V2V logs...', `${v2vEntries.length} file${v2vEntries.length !== 1 ? 's' : ''}`);\n    // Parse each V2V file individually so the UI can show per-file analysis\n    for (const entry of v2vEntries) {\n      const data = parseV2VLog(entry.content);\n      data.fileName = entry.path;\n      // Extract plan name and VM ID from the archive path\n      const match = V2V_PATH_RE.exec(entry.path);\n      v2vFileEntries.push({\n        filePath: entry.path,\n        data,\n        planName: match?.[2],\n        vmId: match ? `vm-${match[3]}` : undefined,\n      });\n    }\n  }\n\n  // 4. Merge\n  onProgress?.('Merging results...');\n  const parsedData = mergeResults(logResult, yamlResult);\n\n  return {\n    logFiles: logEntries.map((e) => e.path),\n    yamlFiles: yamlEntries.map((e) => e.path),\n    v2vFiles: v2vEntries.map((e) => e.path),\n    v2vFileEntries,\n    parsedData,\n  };\n}\n\n/**\n * Parse multiple log files individually instead of joining them into one\n * giant string and splitting again.  This avoids a peak-memory spike from\n * the intermediate concatenated string and the re-allocated split array.\n */\nfunction parseLogFilesIndividually(entries: TarEntry[]): ParsedData {\n  if (entries.length === 1) {\n    return parseLogFile(entries[0].content);\n  }\n\n  // Parse each file separately and merge the results\n  let merged: ParsedData | null = null;\n  for (const entry of entries) {\n    const result = parseLogFile(entry.content);\n    merged = merged ? mergeResults(merged, result) : result;\n  }\n  return merged ?? mergeResults(null, null);\n}\n","/**\n * Web Worker for processing archive files off the main thread.\n *\n * Receives a File via postMessage, runs the full extraction  classification\n *  parsing pipeline, and posts back progress updates and the final result.\n */\n\nimport { processArchive } from './archiveProcessor';\n\nexport interface WorkerProgressMessage {\n  type: 'progress';\n  stage: string;\n  detail?: string;\n}\n\nexport interface WorkerResultMessage {\n  type: 'result';\n  data: import('../types').ArchiveResult;\n}\n\nexport interface WorkerErrorMessage {\n  type: 'error';\n  message: string;\n}\n\nexport type WorkerOutMessage = WorkerProgressMessage | WorkerResultMessage | WorkerErrorMessage;\n\nexport interface WorkerInMessage {\n  type: 'processArchive';\n  file: File;\n}\n\nconst ctx = self as unknown as Worker;\n\nctx.onmessage = async (event: MessageEvent<WorkerInMessage>) => {\n  const msg = event.data;\n\n  if (msg.type === 'processArchive') {\n    try {\n      const result = await processArchive(msg.file, (stage, detail) => {\n        ctx.postMessage({ type: 'progress', stage, detail } satisfies WorkerProgressMessage);\n      });\n      ctx.postMessage({ type: 'result', data: result } satisfies WorkerResultMessage);\n    } catch (err) {\n      ctx.postMessage({\n        type: 'error',\n        message: err instanceof Error ? err.message : String(err),\n      } satisfies WorkerErrorMessage);\n    }\n  }\n};\n"],"names":["ch2","wk","c","id","msg","transfer","cb","w","e","d","ed","err","u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","i","r","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","p","o","bits16","shft","slc","ec","ind","nt","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","n","lt","dt","t","lms","dms","lpos","sym","add","dsym","end","shift","dend","et","mrg","k","wcln","fn","fnStr","td","ks","st_1","spInd","ch","cbfs","wrkr","fns","init","td_1","bInflt","inflateSync","pbf","gopt","cbify","opts","b2","b4","b8","inflate","data","ev","tds","dutf8","strFromU8","latin1","slzh","zh","z","fnl","es","bs","z64e","sc","su","off","mt","unzip","term","tAll","files","cbd","lft","ze","fltr","_loop_3","c_1","no","cbl","infl","TAR_BLOCK","GZIP_MAGIC_0","GZIP_MAGIC_1","MAX_ENTRY_BYTES","SKIP_EXTENSIONS","shouldSkipByExtension","path","lower","dotIdx","extractArchive","input","pathPrefix","bytes","isZip","extractZip","rawEntries","isGzip","streamParseGzippedTar","parseTarBytes","flattenNestedArchives","entries","result","entry","isArchiveEntry","prefix","stripArchiveExt","nested","compressed","reader","controller","StreamingBuffer","parseTarFromStream","__publicField","chunks","collected","done","value","combined","offset","chunk","remaining","decoder","longName","header","isZeroBlock","next","processHeader","readLongName","headerResult","rawName","readString","sizeOctal","typeFlag","size","parseOctal","aligned","alignToBlock","name","fullPath","rawBytes","fileBytes","content","nameBytes","ZIP_MAGIC_0","ZIP_MAGIC_1","unzipAsync","resolve","reject","fflateUnzip","block","length","slice","str","trimmed","MigrationTypes","PlanStatuses","PipelineSteps","Phases","PrecopyLoopPhases","PrecopyLoopPhasesSet","PrecopyLoopStartPhase","WarmOnlyPhases","ColdDiskPhases","phaseToStep","phase","isWarm","ConditionStatus","PanicPrefix","ContainerLogPrefixRegex","VMRegex","parseTimestamp","ts","date","stdMatch","datePart","timePart","ms","isoStr","parseVMInfo","vmStr","matches","getVMInfo","vmObj","truncate","maxLen","getStringFromMap","obj","key","formatDuration","mins","secs","hours","detectVMMigrationType","phaseHistory","hasWarmPhase","hasDiskPhase","hasConversion","ph","groupLogs","logs","groups","order","log","existing","computePhaseLogSummaries","vm","summaries","phaseTimes","summary","phaseInfo","durationMs","buildWarmInfoFromPhaseHistory","iterationMap","phases","precopies","successes","failures","sortedIterations","iteration","startedAt","endedAt","allPhasesCompleted","hasAddCheckpoint","hasCopyDisksStart","isPanicLine","line","LogStore","namespace","plan","mostRecent","event","partial","plans","warmInfo","hasWarm","hasCold","hasOnlyConversion","vmsFound","createVM","processPlanLog","store","planName","vmID","ensureVMExists","lastPhase","processVMPhase","storeVMLog","processSetCheckpoint","processPhaseTransition","processConditionAdded","processConditionDeleted","detectStorageOffload","markVMStorageOffload","processDataVolume","processCreatedResource","processErrorLog","processWarningLog","vmName","getCurrentPrecopyIteration","maxIteration","currentIteration","iterationSuffix","_ts","entryRecord","precopyInfos","isFinal","currentPhase","nextPhase","condType","condStatus","condMessage","condCategory","cond","existingIdx","rawLogEntry","resourceType","resourceName","resourceMatch","fullMsg","errorMsg","raw","processPanicLog","panicMsg","idx","stacktrace","_c","_d","processReconcilerError","panicIdx","recoveredIdx","existingPanic","savePanicStacktrace","lines","lastIdx","parseLogFile","currentPanicPlan","currentPanicLines","inPanicStacktrace","jsonContent","containerTimestamp","parsed","processEntry","processSchedulerLog","entryAny","inflight","pending","snapshot","nextVM","loggerParts","planRef","isNothing","subject","isObject","toArray","sequence","extend","target","source","index","sourceKeys","repeat","string","count","cycle","isNegativeZero","number","isNothing_1","isObject_1","toArray_1","repeat_1","isNegativeZero_1","extend_1","common","formatError","exception","compact","where","message","YAMLException$1","reason","mark","getLine","buffer","lineStart","lineEnd","position","maxLineLength","head","tail","maxHalfLength","padStart","makeSnippet","options","re","lineStarts","lineEnds","match","foundLineNo","lineNoLength","snippet","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","compileStyleAliases","map","style","alias","Type$1","tag","compileList","schema","currentType","newIndex","previousType","previousIndex","compileMap","collectType","Schema$1","definition","implicit","explicit","type$1","seq","failsafe","resolveYamlNull","constructYamlNull","isNull","object","_null","resolveYamlBoolean","constructYamlBoolean","isBoolean","bool","isHexCode","isOctCode","isDecCode","resolveYamlInteger","hasDigits","constructYamlInteger","sign","isInteger","int","YAML_FLOAT_PATTERN","resolveYamlFloat","constructYamlFloat","SCIENTIFIC_WITHOUT_DOT","representYamlFloat","res","isFloat","float","json","core","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","resolveYamlTimestamp","constructYamlTimestamp","year","month","day","hour","minute","second","fraction","delta","tz_hour","tz_minute","representYamlTimestamp","timestamp","resolveYamlMerge","merge","BASE64_MAP","resolveYamlBinary","code","bitlen","constructYamlBinary","tailbits","representYamlBinary","isBinary","binary","_hasOwnProperty$3","_toString$2","resolveYamlOmap","objectKeys","pair","pairKey","pairHasKey","constructYamlOmap","omap","_toString$1","resolveYamlPairs","keys","constructYamlPairs","pairs","_hasOwnProperty$2","resolveYamlSet","constructYamlSet","set","_default","_hasOwnProperty$1","CONTEXT_FLOW_IN","CONTEXT_FLOW_OUT","CONTEXT_BLOCK_IN","CONTEXT_BLOCK_OUT","CHOMPING_CLIP","CHOMPING_STRIP","CHOMPING_KEEP","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","escapedHexLen","fromDecimalCode","simpleEscapeSequence","charFromCodepoint","setProperty","simpleEscapeCheck","simpleEscapeMap","State$1","generateError","state","throwError","throwWarning","directiveHandlers","args","major","minor","handle","captureSegment","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startLineStart","startPos","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readPlainScalar","nodeIndent","withinFlowCollection","preceding","following","captureStart","captureEnd","hasPendingContent","_line","_lineStart","_lineIndent","_kind","readSingleQuotedScalar","readDoubleQuotedScalar","hexLength","hexResult","tmp","readFlowCollection","readNext","_pos","_tag","_anchor","terminator","isPair","isExplicitPair","isMapping","composeNode","readBlockScalar","folding","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockSequence","detected","readBlockMapping","flowIndent","allowCompact","_keyLine","_keyLineStart","_keyPos","atExplicitKey","readTagProperty","isVerbatim","isNamed","tagHandle","tagName","readAnchorProperty","readAlias","parentIndent","nodeContext","allowToSeek","allowBlockStyles","allowBlockScalars","allowBlockCollections","indentStatus","atNewLine","hasContent","typeIndex","typeQuantity","typeList","blockIndent","readDocument","documentStart","directiveName","directiveArgs","hasDirectives","loadDocuments","nullpos","loadAll$1","iterator","documents","load$1","loadAll_1","load_1","loader","_toString","_hasOwnProperty","CHAR_BOM","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_EQUALS","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","compileStyleMap","encodeHex","character","QUOTING_TYPE_SINGLE","QUOTING_TYPE_DOUBLE","State","indentString","spaces","generateNextLine","level","testImplicitResolving","isWhitespace","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","isPlainSafeFirst","isPlainSafeLast","codePointAt","first","needIndentIndicator","leadingSpaceRe","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","lineWidth","testAmbiguousType","quotingType","forceQuotes","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","writeScalar","iskey","indent","testAmbiguity","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","foldLine","prevMoreIndented","moreIndented","breakRe","curr","escapeSeq","writeFlowSequence","writeNode","writeBlockSequence","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","detectType","isblockseq","tagStr","objectOrArray","duplicateIndex","duplicate","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","dump$1","dump_1","dumper","renamed","from","to","Type","Schema","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SCHEMA","load","loadAll","dump","YAMLException","types","safeLoad","safeLoadAll","safeDump","jsYaml","parsePlanYaml","parsePlanYamlImpl","docs","yaml","planResources","networkMapResources","storageMapResources","doc","list","item","isPlanResource","isNetworkMapResource","isStorageMapResource","convertPlanResource","networkMaps","convertNetworkMapResource","storageMaps","convertStorageMapResource","stats","sum","resource","ownerPlanName","_e","ref","_f","provider","_g","conditions","_h","references","_j","_i","specType","migrationType","archived","status","vms","migrationVMs","migration","hasError","step","allCompleted","yamlVM","convertVMStatus","migStarted","_k","migCompleted","_m","_l","spec","_n","_p","_o","_r","_q","_t","_s","_v","_u","_w","_x","planMigrationType","vmId","precopyCount","phaseLogs","phaseLogSummaries","stepNameMap","stepName","phaseName","isDiskTransfer","stepPhase","isPending","started","completed","logTimestamp","unit","progressStr","task","addPrecopyLogs","vmError","vmConditions","currentStep","vmStarted","vmCompleted","warm","precopy","disks","STAGE_RE","KERNEL_BOOT_RE","LIBGUESTFS_TRACE_RE","LIBGUESTFS_DRIVE_RE","LIBGUESTFS_MEMSIZE_RE","LIBGUESTFS_SMP_RE","LIBGUESTFS_BACKEND_RE","LIBGUESTFS_ID_RE","COMMAND_RE","CMD_RETURN_RE","CMD_STDOUT_RE","COMMANDRVF_META_RE","COMMANDRVF_EXEC_RE","CHROOT_RE","LIBGUESTFS_CMD_RE","MONITOR_PROGRESS_RE","MONITOR_DISK_RE","GUESTFSD_START_RE","GUESTFSD_END_RE","ERROR_RE","WARNING_RE","HOST_FREE_SPACE_RE","VERSION_VIRTV2V_RE","VERSION_LIBVIRT_RE","VERSION_NBDKIT_RE","VERSION_VDDK_RE","VERSION_QEMU_RE","VERSION_LIBGUESTFS_RE","VERSION_VIRTIO_WIN_RE","ERROR_FALSE_POSITIVES","KNOWN_PREFIXES","NOISY_COMMANDS","NOISY_LINE_RE","CORRUPTED_PREFIX_RE","VERSION_MATCHERS","categorizeLine","isErrorFalsePositive","isKnownPrefix","isNoisyCommand","parseCommandArgs","argsStr","fp","extractSource","inferExitStatus","stages","errors","rawLines","hasFinishingOff","hasMonitorFinished","hasFatalError","buildHostCommand","parts","lineNumber","command","findQueueByApiName","openApiCalls","apiName","suffix","queue","attachGuestfsdToApiCall","scope","completedApiCalls","q","parseVersionFields","versions","fmt","parseHexEscapeAt","hex","val","flushHivexSession","session","accesses","keyPath","actualMode","last","decodeHivexData","rawData","regType","parseEscapedHivexBytes","decodeUtf16LE","esc","NBDKIT_SOCKET_RE","NBDKIT_URI_RE","NBDKIT_PLUGIN_RE","NBDKIT_FILTER_RE","NBDKIT_FILE_RE","NBDKIT_SERVER_RE","NBDKIT_VM_RE","NBDKIT_TRANSPORT_RE","COW_FILE_SIZE_RE","finalizeNbdkit","nbdkit","endLine","parseInstalledApps","resultStr","apps","listStart","fields","app","extractAppField","marker","nextField","extractCPEVersion","productName","ver","buildGuestInfo","driveMappings","mappingsStr","part","entryRe","fstab","fstabStr","fm","majorVersion","minorVersion","cpeVersion","vParts","BLKID_LINE_RE","BLKID_KV_RE","parseBlkidLine","device","kvMatches","kv","parseLibvirtXML","xml","nameMatch","memMatch","cpuMatch","osTypeMatch","diskRe","diskMatch","srcFile","netRe","netMatch","netType","model","ORIGINAL_SIZE_RE","extractOriginalSize","decodeWriteEscapes","extractReadFileContent","startIdx","contentStart","contentEnd","rawContent","extractWriteContent","destPath","createParseContext","sectionLines","globalLineOffset","HIVEX_HANDLE_NAME_RE","HIVEX_QUOTED_STRING_RE","resetHivexTraversal","ctx","overrides","addGuestCommand","cmd","allOpen","lastQueue","findLastGuestCommand","cmdName","cmds","handleStdoutCapture","handlePipelineStages","globalLine","stageMatch","handleMonitorProgress","progressMatch","lastDisk","handleVersionsAndDiskInfo","handleLibvirtXML","handleNbdkit","isNbdkitStart","socketMatch","uriMatch","pluginMatch","filterMatch","fileMatch","serverMatch","vmMatch","transportMatch","cowMatch","lastConn","handleLibguestfsTrace","backendMatch","idMatch","traceMatch","traceHandle","apiArgs","smpMatch","driveMatch","handleHivexTrace","lastCall","apiCall","queueKey","resultName","resultValue","lastLgCall","resultKey","cmdMatch","cmdText","hiveMatch","openMode","resultVal","childMatch","parentHandle","childName","addMatch","valNameMatch","strMatch","setMatch","valName","handleLibguestfsCmdFlush","handleGuestfsdScope","startMatch","endMatch","durationSecs","guestfsdApiName","durationQueue","handleGuestCommands","stdoutHeaderMatch","retMatch","retCode","cmdExecMatch","rvfMatch","chrootMatch","handleGuestInfo","iMatch","rootHeaderMatch","fsHeaderMatch","indentedMatch","mappedKey","handleBlkid","blkidEntry","handleFileCopies","isoMatch","readFileMatch","readSize","v2vReadFileMatch","readPath","pendingSize","contentResult","writeMatch","dest","writeSize","contentTruncated","readInfo","uploadMatch","src","handleErrors","flushPendingState","conn","CONTAINER_TS_PREFIX_RE","BUILD_CMD_SPACE_RE","BUILD_CMD_NOSPACE_RE","isV2VLog","parseV2VLog","parseV2VLogImpl","preprocessLines","totalLines","boundaries","findToolRunBoundaries","toolRuns","toolRun","parseToolRunSection","tool","detectToolFromContent","splitConcatenatedBuildCommands","traceIdx","tracePart","secondIdx","spaceMatch","indices","searchFrom","classifyTool","noSpaceMatch","commandLine","category","libguestfs","exitStatus","mergeResults","emptyResult","mergeBoth","deduplicateMaps","seen","dataA","dataB","bPlanMap","planKey","mergedPlans","matchedKeys","planA","planB","mergePlans","events","computeSummary","hasLogData","bHasLogs","aHasLogs","base","other","merged","existingTypes","otherVM","baseVM","enrichVM","V2V_PATH_RE","NON_LOG_EXTENSIONS","isV2VLogByPath","ext","LOG_SIGNATURES","CLASSIFY_CHECK_BYTES","isForkliftLogFile","sample","sig","firstLine","PLAN_KIND_RE","NETWORKMAP_KIND_RE","STORAGEMAP_KIND_RE","FORKLIFT_API_RE","isForkliftYamlFile","processArchive","file","onProgress","processArchiveImpl","logEntries","yamlEntries","v2vEntries","logResult","yamlResult","v2vFileEntries","parseLogFilesIndividually","parsedData","stage","detail"],"mappings":"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","x_google_ignoreList":[0,8]}